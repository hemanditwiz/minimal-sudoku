{"version":3,"sources":["../webpack/bootstrap","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator/index.js","../node_modules/symbol-observable/es/index.js","../node_modules/workerize-redux/lib/index.js","../node_modules/symbol-observable/es/ponyfill.js","../node_modules/webpack/buildin/harmony-module.js","../node_modules/regenerator-runtime/runtime.js","../node_modules/workerize-redux/lib/workerizeRedux.js","../node_modules/workerize-redux/lib/applyWorker.js","../node_modules/webpack/buildin/global.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","constants/index.ts","global/index.ts","utils/grid.ts","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","utils/shuffle.ts","utils/checkValue.ts","utils/identifySquare.ts","utils/game.ts","utils/solveGrid.ts","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../../src/utils/errors.ts","../../src/utils/common.ts","../../src/types/types-internal.ts","../../src/utils/plugins.ts","../../src/core/scope.ts","../../src/core/finalize.ts","../../src/core/proxy.ts","../../src/core/immerClass.ts","../../src/core/current.ts","../../src/plugins/es5.ts","../../src/immer.ts","../../src/utils/env.ts","../node_modules/redux/es/redux.js","../node_modules/reselect/es/index.js","../node_modules/redux-thunk/es/index.js","../../src/devtoolsExtension.ts","../../src/createAction.ts","../../src/mapBuilders.ts","../../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../../src/index.ts","slices/gridSlice.ts","../../src/createSlice.ts","../../src/createReducer.ts","utils/checkSolution.ts","worker/sudoku.worker.ts"],"names":["self","chunkIds","moreModules","moduleId","modules","length","installedChunks","pop","installedModules","0","installedWasmModules","wasmImportObjects","13","p0i32","exports","p1i32","p2i32","__webpack_require__","module","i","l","call","e","chunkId","promises","push","Promise","resolve","then","importScripts","p","forEach","wasmModuleId","installedWasmModuleData","promise","importObject","req","fetch","WebAssembly","compileStreaming","all","items","instantiate","instantiateStreaming","x","arrayBuffer","bytes","res","w","instance","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","s","root","window","global","result","ponyfill","workerizeRedux_1","require","applyWorker_1","applyWorker","createWorker","reducer","workerizeRedux","WorkerizeRedux","addWorkerReducer","symbolObservablePonyfill","observable","originalModule","webpackPolyfill","children","runtime","Op","hasOwn","$Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","define","obj","configurable","writable","err","wrap","innerFn","outerFn","tryLocsList","protoGenerator","Generator","generator","context","Context","_invoke","state","method","arg","Error","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","done","makeInvokeMethod","fn","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","AsyncIterator","PromiseImpl","previousPromise","callInvokeWithMethodAndArg","reject","invoke","__await","unwrapped","error","undefined","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","constructor","displayName","isGeneratorFunction","genFun","ctor","mark","setPrototypeOf","__proto__","awrap","async","iter","toString","keys","reverse","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","regeneratorRuntime","accidentalStrictMode","Function","__awaiter","thisArg","_arguments","P","fulfilled","step","rejected","apply","__generator","body","f","y","g","_","label","trys","ops","verb","v","op","ctx","_this","reducerFn","actionHandler","evt","_a","action","successActionType","payload","_b","data","worker","postMessage","destroy","removeEventListener","addEventListener","isFirstTime","store","Worker","dispatch","getState","asyncGeneratorStep","gen","_next","_throw","_asyncToGenerator","args","arguments","_arrayLikeToArray","arr","len","arr2","Array","_unsupportedIterableToArray","minLen","from","test","_toConsumableArray","isArray","_slicedToArray","_arr","_n","_d","_e","_s","_i","globals","counter","numbers","getEmptyIndex","grid","j","fillGrid","emptyIndex","row","col","F","it","normalCompletion","didErr","_e2","shuffle","isValidInsert","removeNumbersFromGrid","completeGrid","attempts","copyGrid","removedBlocks","randomNumberGenerator","backup","gridCopy","solveGrid","createFullGrid","fill","map","number","Math","floor","random","array","arrayCopy","includes","isInGridRow","isInGridColumn","identifyWorkingSquare","flat","isInGridSquare","square","rowLowerLimit","wasmGrid","createNewGameFromWasm","a","level","catch","grid2d","blocks","GRID_SIZE","clear","set_difficulty","solve","solvedGrid","get_blocks_array","generate_puzzle","challengeGrid","activeGrid","remainingBlocks","get_removed_blocks_count","actualRemainingBlocks","_defineProperty","ownKeys","enumerableOnly","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","_objectSpread2","target","source","getOwnPropertyDescriptors","defineProperties","die","msg","join","isDraft","DRAFT_STATE","isDraftable","proto","DRAFTABLE","isMap","isSet","each","getArchtype","index","thing","type_","has","prop","set","propOrOldValue","delete","add","is","hasMap","Map","hasSet","Set","latest","copy_","base_","shallowCopy","base","descriptors","desc","freeze","deep","isFrozen","dontMutateFrozenCollections","getPlugin","pluginKey","plugin","plugins","loadPlugin","implementation","getCurrentScope","currentScope","usePatchesInScope","scope","patchListener","patches_","inversePatches_","patchListener_","revokeScope","leaveScope","drafts_","revokeDraft","parent_","enterScope","immer","immer_","canAutoFreeze_","unfinalizedDrafts_","draft","revoke_","revoked_","processResult","baseDraft","isReplaced","useProxies_","willFinalizeES5_","modified_","finalize","maybeFreeze","generateReplacementPatches_","NOTHING","rootScope","path","childValue","finalizeProperty","scope_","finalized_","draft_","generatePatches_","parentState","targetObject","rootPath","assigned_","concat","autoFreeze_","peek","getDescriptorFromProto","markChanged","prepareCopy","createProxy","parent","proxyMap_","proxySet_","isManual_","traps","objectTraps","arrayTraps","Proxy","revocable","revoke","proxy","createES5Proxy_","copyHelper","archType","enableES5","proxyProperty","markChangesSweep","drafts","hasArrayChanges","hasObjectChanges","baseValue","baseIsDraft","descriptor","markChangesRecursively","min","hasChanges_","hasSymbol","hasProxies","Reflect","for","getOwnPropertyNames","deleteProperty","owner","config","useProxies","setUseProxies","autoFreeze","setAutoFreeze","produce","produceWithPatches","recipe","defaultBase","hasError","arg1","arg2","patches","inversePatches","_this2","ip","createDraft","currentImpl","copy","current","finishDraft","applyPatches","patch","applyPatchesImpl","applyPatches_","randomString","substring","split","compose","_len","funcs","_key","reduce","b","defaultEqualityCheck","areArgumentsShallowlyEqual","equalityCheck","getDependencies","dependencies","every","dep","dependencyTypes","memoize","memoizeOptions","createSelectorCreator","func","lastArgs","lastResult","createThunkMiddleware","extraArgument","_ref","thunk","withExtraArgument","createAction","prepareAction","prepared","meta","actionCreator","executeReducerBuilderCallback","builderCallback","actionsMap","actionMatchers","builder","addCase","typeOrActionCreator","addMatcher","matcher","addDefaultCase","defaultCaseReducer","gridSlice","options","initialState","reducers","extraReducers","reducerNames","sliceCaseReducersByName","sliceCaseReducersByType","actionCreators","reducerName","maybeReducerWithPrepare","caseReducer","prepareCallback","mapOrBuilderCallback","finalActionMatchers","finalDefaultCaseReducer","caseReducers","cr","createNextState","previousState","createReducer","actions","createSlice","easy","medium","hard","expert","createNewGame","selectedBlock","difficulty","loading","hideClues","victoryModalOpen","moves","startNewGame","resetGame","selectBlock","setDifficulty","closeModal","startLoading","toggleHideClues","fillBlock","previousValue","userGrid","solutionGrid","userList","checkSolution","newGameFromWorker","gridReducer"],"mappings":"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","file":"static/js/sudoku.worker.25219f27.worker.js","sourcesContent":[" \tself[\"webpackChunk\"] = function webpackChunkCallback(chunkIds, moreModules) {\n \t\tfor(var moduleId in moreModules) {\n \t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t}\n \t\twhile(chunkIds.length)\n \t\t\tinstalledChunks[chunkIds.pop()] = 1;\n \t};\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded chunks\n \t// \"1\" means \"already loaded\"\n \tvar installedChunks = {\n \t\t0: 1\n \t};\n\n \t// object to store loaded and loading wasm modules\n \tvar installedWasmModules = {};\n\n \tfunction promiseResolve() { return Promise.resolve(); }\n\n \tvar wasmImportObjects = {\n \t\t13: function() {\n \t\t\treturn {\n \t\t\t\t\"./sudoku_wasm_bg.js\": {\n \t\t\t\t\t\"__wbindgen_object_drop_ref\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[10].exports[\"l\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbindgen_is_undefined\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[10].exports[\"j\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_buffer_88f603259d7a7b82\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[10].exports[\"b\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_newwithbyteoffsetandlength_5ba4b4465eeaa8d3\": function(p0i32,p1i32,p2i32) {\n \t\t\t\t\t\treturn installedModules[10].exports[\"f\"](p0i32,p1i32,p2i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_getRandomValues_f5e14ab7ac8e995d\": function(p0i32,p1i32,p2i32) {\n \t\t\t\t\t\treturn installedModules[10].exports[\"e\"](p0i32,p1i32,p2i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_randomFillSync_d5bd2d655fdf256a\": function(p0i32,p1i32,p2i32) {\n \t\t\t\t\t\treturn installedModules[10].exports[\"g\"](p0i32,p1i32,p2i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_self_1b7a39e3a92c949c\": function() {\n \t\t\t\t\t\treturn installedModules[10].exports[\"i\"]();\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_require_604837428532a733\": function(p0i32,p1i32) {\n \t\t\t\t\t\treturn installedModules[10].exports[\"h\"](p0i32,p1i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_crypto_968f1772287e2df0\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[10].exports[\"c\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_getRandomValues_a3d34b4fee3c2869\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[10].exports[\"d\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbindgen_throw\": function(p0i32,p1i32) {\n \t\t\t\t\t\treturn installedModules[10].exports[\"m\"](p0i32,p1i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbindgen_memory\": function() {\n \t\t\t\t\t\treturn installedModules[10].exports[\"k\"]();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t};\n \t\t},\n \t};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId) {\n \t\tvar promises = [];\n \t\tpromises.push(Promise.resolve().then(function() {\n \t\t\t// \"1\" is the signal for \"already loaded\"\n \t\t\tif(!installedChunks[chunkId]) {\n \t\t\t\timportScripts(__webpack_require__.p + \"static/js/\" + ({}[chunkId]||chunkId) + \".\" + {\"1\":\"9afa6863\"}[chunkId] + \".chunk.worker.js\");\n \t\t\t}\n \t\t}));\n\n \t\t// Fetch + compile chunk loading for webassembly\n\n \t\tvar wasmModules = {\"1\":[13]}[chunkId] || [];\n\n \t\twasmModules.forEach(function(wasmModuleId) {\n \t\t\tvar installedWasmModuleData = installedWasmModules[wasmModuleId];\n\n \t\t\t// a Promise means \"currently loading\" or \"already loaded\".\n \t\t\tif(installedWasmModuleData)\n \t\t\t\tpromises.push(installedWasmModuleData);\n \t\t\telse {\n \t\t\t\tvar importObject = wasmImportObjects[wasmModuleId]();\n \t\t\t\tvar req = fetch(__webpack_require__.p + \"\" + {\"13\":\"b3d4f08e307c222bddef\"}[wasmModuleId] + \".module.wasm\");\n \t\t\t\tvar promise;\n \t\t\t\tif(importObject instanceof Promise && typeof WebAssembly.compileStreaming === 'function') {\n \t\t\t\t\tpromise = Promise.all([WebAssembly.compileStreaming(req), importObject]).then(function(items) {\n \t\t\t\t\t\treturn WebAssembly.instantiate(items[0], items[1]);\n \t\t\t\t\t});\n \t\t\t\t} else if(typeof WebAssembly.instantiateStreaming === 'function') {\n \t\t\t\t\tpromise = WebAssembly.instantiateStreaming(req, importObject);\n \t\t\t\t} else {\n \t\t\t\t\tvar bytesPromise = req.then(function(x) { return x.arrayBuffer(); });\n \t\t\t\t\tpromise = bytesPromise.then(function(bytes) {\n \t\t\t\t\t\treturn WebAssembly.instantiate(bytes, importObject);\n \t\t\t\t\t});\n \t\t\t\t}\n \t\t\t\tpromises.push(installedWasmModules[wasmModuleId] = promise.then(function(res) {\n \t\t\t\t\treturn __webpack_require__.w[wasmModuleId] = (res.instance || res).exports;\n \t\t\t\t}));\n \t\t\t}\n \t\t});\n \t\treturn Promise.all(promises);\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/minimal-sudoku/\";\n\n \t// object with all WebAssembly.instance exports\n \t__webpack_require__.w = {};\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 9);\n","module.exports = require(\"regenerator-runtime\");\n","/* global window */\nimport ponyfill from './ponyfill.js';\n\nvar root;\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (typeof module !== 'undefined') {\n  root = module;\n} else {\n  root = Function('return this')();\n}\n\nvar result = ponyfill(root);\nexport default result;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar workerizeRedux_1 = require(\"./workerizeRedux\");\nvar applyWorker_1 = require(\"./applyWorker\");\nexports.applyWorker = applyWorker_1.applyWorker;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexports.createWorker = function (reducer) {\n    var workerizeRedux = new workerizeRedux_1.WorkerizeRedux();\n    workerizeRedux.addWorkerReducer(reducer);\n    return workerizeRedux;\n};\n","export default function symbolObservablePonyfill(root) {\n\tvar result;\n\tvar Symbol = root.Symbol;\n\n\tif (typeof Symbol === 'function') {\n\t\tif (Symbol.observable) {\n\t\t\tresult = Symbol.observable;\n\t\t} else {\n\t\t\tresult = Symbol('observable');\n\t\t\tSymbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n};\n","module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nvar ctx = self;\nvar WorkerizeRedux = /** @class */ (function () {\n    function WorkerizeRedux() {\n        var _this = this;\n        this.reducerFn = function (state) { return state; };\n        this.actionHandler = function (evt) { return __awaiter(_this, void 0, void 0, function () {\n            var _a, state, action, successActionType, payload;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _a = evt.data, state = _a.state, action = _a.action, successActionType = _a.successActionType;\n                        if (!(action.worker && typeof action.type === 'string')) return [3 /*break*/, 2];\n                        return [4 /*yield*/, this.reducerFn(state, action)];\n                    case 1:\n                        payload = _b.sent();\n                        ctx.postMessage({\n                            worker: true,\n                            successActionType: successActionType,\n                            payload: payload\n                        });\n                        _b.label = 2;\n                    case 2: return [2 /*return*/];\n                }\n            });\n        }); };\n        this.addWorkerReducer = function (reducerFn) {\n            _this.reducerFn = reducerFn;\n        };\n        this.destroy = function () {\n            ctx.removeEventListener('message', _this.actionHandler);\n        };\n        ctx.addEventListener('message', this.actionHandler);\n    }\n    return WorkerizeRedux;\n}());\nexports.WorkerizeRedux = WorkerizeRedux;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar isFirstTime = true;\nexports.applyWorker = function (worker) { return function (store) { return function (next) { return function (action) {\n    if (isFirstTime && worker instanceof Worker) {\n        isFirstTime = false;\n        worker.addEventListener('message', function (evt) {\n            if (store.dispatch &&\n                evt.data.worker &&\n                evt.data.successActionType) {\n                store.dispatch({\n                    type: evt.data.successActionType,\n                    payload: evt.data.payload\n                });\n            }\n        });\n    }\n    if (action.worker && action.successActionType) {\n        worker.postMessage({\n            state: store.getState(),\n            action: action,\n            successActionType: action.successActionType\n        });\n    }\n    else {\n        return next(action);\n    }\n}; }; }; };\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nexport default function _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayLikeToArray from \"./arrayLikeToArray\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","import arrayWithoutHoles from \"./arrayWithoutHoles\";\nimport iterableToArray from \"./iterableToArray\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray\";\nimport nonIterableSpread from \"./nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import arrayWithHoles from \"./arrayWithHoles\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray\";\nimport nonIterableRest from \"./nonIterableRest\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","export const GRID_SIZE = 9;\nexport const EMPTY_VALUE = 0;\nexport const REMOVE_NUMBERS_COUNT = 32;\nexport const ATTEMPT_EASY = 3;\nexport const ATTEMPT_MEDIUM = 4;\nexport const ATTEMPT_HARD = 5;\nexport const ATTEMPT_EXPERT = 10;\nexport const NUMBERS = ['1', '2', '3', '4', '5', '6', '7', '8', '9'];\nexport const difficultyLevels: ['easy', 'medium', 'hard', 'expert'] = ['easy', 'medium', 'hard', 'expert'];\n","export const globals = {\n  counter: 0,\n};\n","import { Grid, Numbers } from 'types';\nimport { GRID_SIZE, EMPTY_VALUE } from '../constants';\nimport {\n  shuffle,\n  randomNumberGenerator,\n  isValidInsert,\n  solveGrid,\n} from 'utils';\nimport { globals } from 'global';\n\nconst numbers: Numbers[] = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n\nexport const getRowIndex = (index: number, gridSize: number) =>\n  Math.floor(index / gridSize);\n\nexport const getColIndex = (index: number, gridSize: number) =>\n  index % gridSize;\n\n/**\n * Creates and returns and empty grid\n * @returns {Grid} returns newly created grid\n */\nexport const buildEmptyGrid = (): Grid =>\n  Array(GRID_SIZE)\n    .fill(EMPTY_VALUE)\n    .map(() => Array(GRID_SIZE).fill(EMPTY_VALUE)) as Grid;\n\n\nexport const getEmptyIndex = (grid: Grid) => {\n  for (let i = 0; i < GRID_SIZE; i++) {\n    for (let j = 0; j < GRID_SIZE; j++) {\n      if (grid[i][j] === EMPTY_VALUE) {\n        return [i, j];\n      }\n    }\n  }\n  return null;\n};\n\n\n/**\n * A backtracking / recursive function to check all possible combinations\n * of numbers till a solution is found.\n * @param {Grid} grid\n */\nexport const fillGrid = (grid: Grid) => {\n  const emptyIndex = getEmptyIndex(grid);\n  if (!emptyIndex) {\n    return true;\n  }\n\n  let [row, col] = emptyIndex;\n  const shuffledNumbers = shuffle<Numbers>(numbers);\n  for (let value of shuffledNumbers) {\n    const args = { grid, row, col, value };\n    if (isValidInsert(args)) {\n      grid[row][col] = value;\n      if (fillGrid(grid)) {\n        return true;\n      }\n      grid[row][col] = EMPTY_VALUE;\n    }\n  }\n  return false;\n};\n\n/**\n * Removes numbers from a full grid to create a Sudoku Puzzle.\n * @param {Grid} completeGrid\n * @param {number} attempts - number of attempts to solve (higher means more difficult) - default 5\n */\nexport const removeNumbersFromGrid = (\n  completeGrid: Grid,\n  attempts: number = 5\n) => {\n  const grid = copyGrid(completeGrid);\n  let removedBlocks = 0;\n\n  while (attempts > 0) {\n    let row = randomNumberGenerator(GRID_SIZE);\n    let col = randomNumberGenerator(GRID_SIZE);\n\n    while (grid[row][col] === 0) {\n      row = randomNumberGenerator(GRID_SIZE);\n      col = randomNumberGenerator(GRID_SIZE);\n    }\n\n    const backup = grid[row][col];\n    grid[row][col] = 0;\n\n    const gridCopy = copyGrid(grid);\n\n    globals.counter = 0;\n    solveGrid(gridCopy);\n    if (globals.counter !== 1) {\n      grid[row][col] = backup;\n      attempts--;\n    } else {\n      removedBlocks++;\n    }\n  }\n\n  return { grid, removedBlocks };\n};\n\n/**\n * Creates an empty grid and fills it with values\n * @return {Grid}\n */\nexport const createFullGrid = () => {\n  const grid = buildEmptyGrid();\n  fillGrid(grid);\n  return grid;\n};\n\n/**\n * Copies the current grid and returns a new Grid\n * @param {Grid} grid\n * @return {Grid}\n */\nexport const copyGrid = (grid: Grid) => {\n  return grid.map(row => [...row]) as Grid;\n};\n","import unsupportedIterableToArray from \"./unsupportedIterableToArray\";\nexport default function _createForOfIteratorHelper(o) {\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (o = unsupportedIterableToArray(o))) {\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var it,\n      normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","/**\n * Generates a random number between 0 and specified number\n * @param number - Specify the endLimit\n */\nexport const randomNumberGenerator = (number: number) => {\n  return Math.floor(Math.random() * number);\n};\n\n/**\n * Fisher-Yates Array shuffling algorithm\n * @param array\n */\nexport const shuffle = <T extends any>(array: T[]): T[] => {\n  let arrayCopy = [...array];\n  let n = arrayCopy.length;\n\n  while (n) {\n    let i = randomNumberGenerator(n--);\n    [arrayCopy[i], arrayCopy[n]] = [arrayCopy[n], arrayCopy[i]];\n  }\n  return arrayCopy;\n};\n","import { Grid, Numbers } from 'types';\nimport { identifyWorkingSquare } from 'utils';\n\ninterface IsNumberInGrid {\n  grid: Grid;\n  value: Numbers;\n}\n\ninterface NumberInGridRow extends IsNumberInGrid {\n  row: number;\n}\n\ninterface NumberInGridCol extends IsNumberInGrid {\n  col: number;\n}\n\ninterface NumberInGridSquare\n  extends IsNumberInGrid,\n    NumberInGridRow,\n    NumberInGridCol {}\n\n/**\n * Check if value is in the grid row\n * @param param0\n */\nexport const isInGridRow = ({ grid, row, value }: NumberInGridRow): boolean =>\n  grid[row].includes(value);\n\n/**\n * Check if value is in the grid column\n * @param param0\n */\nexport const isInGridColumn = ({\n  grid,\n  col,\n  value,\n}: NumberInGridCol): boolean => {\n  for (let i = 0; i < grid.length; i++) {\n    if (grid[i][col] === value) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Check if value is in the current grid square\n * @param param0\n */\nexport const isInGridSquare = ({\n  grid,\n  row,\n  col,\n  value,\n}: NumberInGridSquare): boolean => {\n  const workingSquare = identifyWorkingSquare({ grid, col, row });\n  return workingSquare.flat(1).includes(value);\n};\n\nexport const isValidInsert = (args: NumberInGridSquare) => {\n  return !isInGridRow(args) && !isInGridColumn(args) && !isInGridSquare(args);\n};\n","import { Square, Grid } from 'types';\n\ninterface IdentifySquare {\n  grid: Grid;\n  row: number;\n  col: number;\n}\n\n/**\n * Identifies the current working square of a 9x9 grid\n * @param identifySquare  \n */\nexport const identifyWorkingSquare = ({\n  grid,\n  col,\n  row,\n}: IdentifySquare): Square => {\n  const square = [];\n  const colLowerLimit = col < 3 ? 0 : col < 6 ? 3 : 6;\n  const rowLowerLimit = row < 3 ? 0 : row < 6 ? 3 : 6;\n\n  for (let r = rowLowerLimit, c = colLowerLimit; r < rowLowerLimit + 3; r++) {\n    square.push(grid[r].slice(c, c + 3));\n  }\n\n  return square as Square;\n};\n","import { createFullGrid, removeNumbersFromGrid, copyGrid } from 'utils';\nimport {\n  ATTEMPT_EASY,\n  ATTEMPT_MEDIUM,\n  ATTEMPT_HARD,\n  ATTEMPT_EXPERT,\n  EMPTY_VALUE,\n  GRID_SIZE,\n} from '../constants';\n\nimport { Grid, Block, Row, FilledBlock, difficultyLevel } from 'types';\n\nlet wasmGrid: any = null;\n\nexport const createNewGame = (level: difficultyLevel = 'easy') => {\n  const attempts = {\n    easy: ATTEMPT_EASY,\n    medium: ATTEMPT_MEDIUM,\n    hard: ATTEMPT_HARD,\n    expert: ATTEMPT_EXPERT,\n  };\n\n  const solvedGrid = createFullGrid();\n  const { grid: challengeGrid, removedBlocks } = removeNumbersFromGrid(\n    solvedGrid,\n    attempts[level]\n  );\n  const activeGrid = copyGrid(challengeGrid);\n\n  return {\n    challengeGrid,\n    solvedGrid,\n    activeGrid,\n    remainingBlocks: removedBlocks,\n    actualRemainingBlocks: removedBlocks,\n  };\n};\n\nexport const createNewGameFromWasm = async (\n  level: difficultyLevel = 'easy'\n) => {\n  wasmGrid =\n    wasmGrid ||\n    (await import('wasm')\n      .then(res => res.wasmGrid)\n      .catch(err => {\n        throw new Error(\n          `Error occurred while importing web assembly module: ${err}`\n        );\n      }));\n\n  const grid2d = (blocks: Uint32Array) => {\n    let arr = [];\n    for (let i = 0; i < GRID_SIZE * GRID_SIZE; i = i + 9) {\n      arr.push(Array.prototype.slice.call(blocks,i, i + GRID_SIZE) as Row);\n    }\n    return arr;\n  };\n\n  wasmGrid.clear();\n  wasmGrid.set_difficulty(level);\n  wasmGrid.solve();\n  const solvedGrid = grid2d(wasmGrid.get_blocks_array()) as Grid;\n  wasmGrid.generate_puzzle();\n  const challengeGrid = grid2d(wasmGrid.get_blocks_array()) as Grid;\n  const activeGrid = grid2d(wasmGrid.get_blocks_array()) as Grid;\n  const remainingBlocks = wasmGrid.get_removed_blocks_count();\n  const actualRemainingBlocks = remainingBlocks;\n  return {\n    challengeGrid,\n    solvedGrid,\n    activeGrid,\n    remainingBlocks,\n    actualRemainingBlocks,\n  };\n};\n\nexport const isUserFillableBlock = (\n  { row, col }: Block,\n  challengeGrid: Grid\n) => {\n  return challengeGrid[row][col] === EMPTY_VALUE;\n};\n\nexport const isCorrectValue = (\n  { row, col, value }: FilledBlock,\n  solvedGrid: Grid\n) => {\n  return value === solvedGrid[row][col];\n};\n\nexport const isBlockEmpty = (value: number) => {\n  return value === EMPTY_VALUE;\n};\n\nconst isInSameRow = (selectedBlock: Block, block: Block) => {\n  return selectedBlock.row === block.row;\n};\n\nconst isInSameCol = (selectedBlock: Block, block: Block) => {\n  return selectedBlock.col === block.col;\n};\n\nconst isInSameSquare = (selectedBlock: Block, block: Block) => {\n  const colLowerLimit =\n    selectedBlock.col < 3 ? 0 : selectedBlock.col < 6 ? 3 : 6;\n  const colUpperLimit = colLowerLimit + 3;\n  const rowLowerLimit =\n    selectedBlock.row < 3 ? 0 : selectedBlock.row < 6 ? 3 : 6;\n  const rowUpperLimit = rowLowerLimit + 3;\n  return (\n    block.row >= rowLowerLimit &&\n    block.row < rowUpperLimit &&\n    block.col >= colLowerLimit &&\n    block.col < colUpperLimit\n  );\n};\n\nexport const isNeighbor = (selectedBlock: Block, block: Block) => {\n  return (\n    !(selectedBlock.row === block.row && selectedBlock.col === block.col) &&\n    (isInSameCol(selectedBlock, block) ||\n      isInSameRow(selectedBlock, block) ||\n      isInSameSquare(selectedBlock, block))\n  );\n};\n\n\n","import { globals } from 'global';\nimport { Grid, Numbers } from 'types';\nimport { isValidInsert, getEmptyIndex } from 'utils';\nimport { EMPTY_VALUE } from '../constants';\n\n/**\n * A backtracking/recursive function to check all possible combinations of numbers until a solution is found\n * @param grid A 9X9 array consisting of values from 0-9)\n */\nexport const solveGrid = (grid: Grid) => {\n  const emptyIndex = getEmptyIndex(grid);\n  if (!emptyIndex) {\n    globals.counter++;\n    return false;\n  }\n\n  let [row, col] = emptyIndex;\n  for (let value = 1 as Numbers; value <= 9 && globals.counter < 2; value++) {\n    const args = { grid, row, col, value };  \n    if (isValidInsert(args)) {\n      grid[row][col] = value;\n      if (solveGrid(grid)) {\n        return true;\n      }\n      grid[row][col] = EMPTY_VALUE;\n    }\n  }\n  return false;\n};\n\n\nexport default solveGrid;\n","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import defineProperty from \"./defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}","const errors = {\n\t0: \"Illegal state\",\n\t1: \"Immer drafts cannot have computed properties\",\n\t2: \"This object has been frozen and should not be mutated\",\n\t3(data: any) {\n\t\treturn (\n\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\tdata\n\t\t)\n\t},\n\t4: \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\t5: \"Immer forbids circular references\",\n\t6: \"The first or second argument to `produce` must be a function\",\n\t7: \"The third argument to `produce` must be a function or undefined\",\n\t8: \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\t9: \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\t10: \"The given draft is already finalized\",\n\t11: \"Object.defineProperty() cannot be used on an Immer draft\",\n\t12: \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\t13: \"Immer only supports deleting array indices\",\n\t14: \"Immer only supports setting array indices and the 'length' property\",\n\t15(path: string) {\n\t\treturn \"Cannot apply patch, path doesn't resolve: \" + path\n\t},\n\t16: 'Sets cannot have \"replace\" patches.',\n\t17(op: string) {\n\t\treturn \"Unsupported patch operation: \" + op\n\t},\n\t18(plugin: string) {\n\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t},\n\t19: \"plugin not loaded\",\n\t20: \"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\",\n\t21(thing: string) {\n\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t},\n\t22(thing: string) {\n\t\treturn `'current' expects a draft, got: ${thing}`\n\t},\n\t23(thing: string) {\n\t\treturn `'original' expects a draft, got: ${thing}`\n\t}\n} as const\n\nexport function die(error: keyof typeof errors, ...args: any[]): never {\n\tif (__DEV__) {\n\t\tconst e = errors[error]\n\t\tconst msg = !e\n\t\t\t? \"unknown error nr: \" + error\n\t\t\t: typeof e === \"function\"\n\t\t\t? e.apply(null, args as any)\n\t\t\t: e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}${\n\t\t\targs.length ? \" \" + args.join(\",\") : \"\"\n\t\t}. Find the full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n","import {\n\tDRAFT_STATE,\n\tDRAFTABLE,\n\thasSet,\n\tObjectish,\n\tDrafted,\n\tAnyObject,\n\tAnyMap,\n\tAnySet,\n\tImmerState,\n\thasMap,\n\tArchtypeObject,\n\tArchtypeArray,\n\tArchtypeMap,\n\tArchtypeSet,\n\tdie\n} from \"../internal\"\n\n/** Returns true if the given value is an Immer draft */\n/*#__PURE__*/\nexport function isDraft(value: any): boolean {\n\treturn !!value && !!value[DRAFT_STATE]\n}\n\n/** Returns true if the given value can be drafted by Immer */\n/*#__PURE__*/\nexport function isDraftable(value: any): boolean {\n\tif (!value) return false\n\treturn (\n\t\tisPlainObject(value) ||\n\t\tArray.isArray(value) ||\n\t\t!!value[DRAFTABLE] ||\n\t\t!!value.constructor[DRAFTABLE] ||\n\t\tisMap(value) ||\n\t\tisSet(value)\n\t)\n}\n\n/*#__PURE__*/\nexport function isPlainObject(value: any): boolean {\n\tif (!value || typeof value !== \"object\") return false\n\tconst proto = Object.getPrototypeOf(value)\n\treturn !proto || proto === Object.prototype\n}\n\n/** Get the underlying object that is represented by the given draft */\n/*#__PURE__*/\nexport function original<T>(value: T): T | undefined\nexport function original(value: Drafted<any>): any {\n\tif (!isDraft(value)) die(23, value)\n\treturn value[DRAFT_STATE].base_\n}\n\n/*#__PURE__*/\nexport const ownKeys: (target: AnyObject) => PropertyKey[] =\n\ttypeof Reflect !== \"undefined\" && Reflect.ownKeys\n\t\t? Reflect.ownKeys\n\t\t: typeof Object.getOwnPropertySymbols !== \"undefined\"\n\t\t? obj =>\n\t\t\t\tObject.getOwnPropertyNames(obj).concat(\n\t\t\t\t\tObject.getOwnPropertySymbols(obj) as any\n\t\t\t\t)\n\t\t: /* istanbul ignore next */ Object.getOwnPropertyNames\n\nexport const getOwnPropertyDescriptors =\n\tObject.getOwnPropertyDescriptors ||\n\tfunction getOwnPropertyDescriptors(target: any) {\n\t\t// Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274\n\t\tconst res: any = {}\n\t\townKeys(target).forEach(key => {\n\t\t\tres[key] = Object.getOwnPropertyDescriptor(target, key)\n\t\t})\n\t\treturn res\n\t}\n\nexport function each<T extends Objectish>(\n\tobj: T,\n\titer: (key: string | number, value: any, source: T) => void,\n\tenumerableOnly?: boolean\n): void\nexport function each(obj: any, iter: any, enumerableOnly = false) {\n\tif (getArchtype(obj) === ArchtypeObject) {\n\t\t;(enumerableOnly ? Object.keys : ownKeys)(obj).forEach(key => {\n\t\t\tif (!enumerableOnly || typeof key !== \"symbol\") iter(key, obj[key], obj)\n\t\t})\n\t} else {\n\t\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\n\t}\n}\n\n/*#__PURE__*/\nexport function getArchtype(thing: any): 0 | 1 | 2 | 3 {\n\t/* istanbul ignore next */\n\tconst state: undefined | ImmerState = thing[DRAFT_STATE]\n\treturn state\n\t\t? state.type_ > 3\n\t\t\t? state.type_ - 4 // cause Object and Array map back from 4 and 5\n\t\t\t: (state.type_ as any) // others are the same\n\t\t: Array.isArray(thing)\n\t\t? ArchtypeArray\n\t\t: isMap(thing)\n\t\t? ArchtypeMap\n\t\t: isSet(thing)\n\t\t? ArchtypeSet\n\t\t: ArchtypeObject\n}\n\n/*#__PURE__*/\nexport function has(thing: any, prop: PropertyKey): boolean {\n\treturn getArchtype(thing) === ArchtypeMap\n\t\t? thing.has(prop)\n\t\t: Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\n/*#__PURE__*/\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\n\t// @ts-ignore\n\treturn getArchtype(thing) === ArchtypeMap ? thing.get(prop) : thing[prop]\n}\n\n/*#__PURE__*/\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\n\tconst t = getArchtype(thing)\n\tif (t === ArchtypeMap) thing.set(propOrOldValue, value)\n\telse if (t === ArchtypeSet) {\n\t\tthing.delete(propOrOldValue)\n\t\tthing.add(value)\n\t} else thing[propOrOldValue] = value\n}\n\n/*#__PURE__*/\nexport function is(x: any, y: any): boolean {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\treturn x !== x && y !== y\n\t}\n}\n\n/*#__PURE__*/\nexport function isMap(target: any): target is AnyMap {\n\treturn hasMap && target instanceof Map\n}\n\n/*#__PURE__*/\nexport function isSet(target: any): target is AnySet {\n\treturn hasSet && target instanceof Set\n}\n/*#__PURE__*/\nexport function latest(state: ImmerState): any {\n\treturn state.copy_ || state.base_\n}\n\n/*#__PURE__*/\nexport function shallowCopy(base: any) {\n\tif (Array.isArray(base)) return base.slice()\n\tconst descriptors = getOwnPropertyDescriptors(base)\n\tdelete descriptors[DRAFT_STATE as any]\n\tlet keys = ownKeys(descriptors)\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key: any = keys[i]\n\t\tconst desc = descriptors[key]\n\t\tif (desc.writable === false) {\n\t\t\tdesc.writable = true\n\t\t\tdesc.configurable = true\n\t\t}\n\t\t// like object.assign, we will read any _own_, get/set accessors. This helps in dealing\n\t\t// with libraries that trap values, like mobx or vue\n\t\t// unlike object.assign, non-enumerables will be copied as well\n\t\tif (desc.get || desc.set)\n\t\t\tdescriptors[key] = {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true, // could live with !!desc.set as well here...\n\t\t\t\tenumerable: desc.enumerable,\n\t\t\t\tvalue: base[key]\n\t\t\t}\n\t}\n\treturn Object.create(Object.getPrototypeOf(base), descriptors)\n}\n\nexport function freeze(obj: any, deep: boolean): void {\n\tif (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return\n\tif (getArchtype(obj) > 1 /* Map or Set */) {\n\t\tobj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections as any\n\t}\n\tObject.freeze(obj)\n\tif (deep) each(obj, (key, value) => freeze(value, true), true)\n}\n\nfunction dontMutateFrozenCollections() {\n\tdie(2)\n}\n\nexport function isFrozen(obj: any): boolean {\n\tif (obj == null || typeof obj !== \"object\") return true\n\t// See #600, IE dies on non-objects in Object.isFrozen\n\treturn Object.isFrozen(obj)\n}\n","import {\n\tSetState,\n\tImmerScope,\n\tProxyObjectState,\n\tProxyArrayState,\n\tES5ObjectState,\n\tES5ArrayState,\n\tMapState,\n\tDRAFT_STATE\n} from \"../internal\"\n\nexport type Objectish = AnyObject | AnyArray | AnyMap | AnySet\nexport type ObjectishNoSet = AnyObject | AnyArray | AnyMap\n\nexport type AnyObject = {[key: string]: any}\nexport type AnyArray = Array<any>\nexport type AnySet = Set<any>\nexport type AnyMap = Map<any, any>\n\nexport const ArchtypeObject = 0\nexport const ArchtypeArray = 1\nexport const ArchtypeMap = 2\nexport const ArchtypeSet = 3\n\nexport const ProxyTypeProxyObject = 0\nexport const ProxyTypeProxyArray = 1\nexport const ProxyTypeES5Object = 4\nexport const ProxyTypeES5Array = 5\nexport const ProxyTypeMap = 2\nexport const ProxyTypeSet = 3\n\nexport interface ImmerBaseState {\n\tparent_?: ImmerState\n\tscope_: ImmerScope\n\tmodified_: boolean\n\tfinalized_: boolean\n\tisManual_: boolean\n}\n\nexport type ImmerState =\n\t| ProxyObjectState\n\t| ProxyArrayState\n\t| ES5ObjectState\n\t| ES5ArrayState\n\t| MapState\n\t| SetState\n\n// The _internal_ type used for drafts (not to be confused with Draft, which is public facing)\nexport type Drafted<Base = any, T extends ImmerState = ImmerState> = {\n\t[DRAFT_STATE]: T\n} & Base\n","import {\n\tImmerState,\n\tPatch,\n\tImmerScope,\n\tDrafted,\n\tAnyObject,\n\tImmerBaseState,\n\tAnyMap,\n\tAnySet,\n\tProxyTypeES5Array,\n\tProxyTypeES5Object,\n\tProxyTypeMap,\n\tProxyTypeSet,\n\tdie\n} from \"../internal\"\n\n/** Plugin utilities */\nconst plugins: {\n\tPatches?: {\n\t\tgeneratePatches_(\n\t\t\tstate: ImmerState,\n\t\t\tbasePath: PatchPath,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tgenerateReplacementPatches_(\n\t\t\trootState: ImmerState,\n\t\t\treplacement: any,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tapplyPatches_<T>(draft: T, patches: Patch[]): T\n\t}\n\tES5?: {\n\t\twillFinalizeES5_(scope: ImmerScope, result: any, isReplaced: boolean): void\n\t\tcreateES5Proxy_<T>(\n\t\t\tbase: T,\n\t\t\tparent?: ImmerState\n\t\t): Drafted<T, ES5ObjectState | ES5ArrayState>\n\t\thasChanges_(state: ES5ArrayState | ES5ObjectState): boolean\n\t}\n\tMapSet?: {\n\t\tproxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T\n\t\tproxySet_<T extends AnySet>(target: T, parent?: ImmerState): T\n\t}\n} = {}\n\ntype Plugins = typeof plugins\n\nexport function getPlugin<K extends keyof Plugins>(\n\tpluginKey: K\n): Exclude<Plugins[K], undefined> {\n\tconst plugin = plugins[pluginKey]\n\tif (!plugin) {\n\t\tdie(__DEV__ ? 18 : 19, pluginKey)\n\t}\n\t// @ts-ignore\n\treturn plugin\n}\n\nexport function loadPlugin<K extends keyof Plugins>(\n\tpluginKey: K,\n\timplementation: Plugins[K]\n): void {\n\tplugins[pluginKey] = implementation\n}\n\n/** ES5 Plugin */\n\ninterface ES5BaseState extends ImmerBaseState {\n\tassigned_: {[key: string]: any}\n\tparent_?: ImmerState\n\trevoked_: boolean\n}\n\nexport interface ES5ObjectState extends ES5BaseState {\n\ttype_: typeof ProxyTypeES5Object\n\tdraft_: Drafted<AnyObject, ES5ObjectState>\n\tbase_: AnyObject\n\tcopy_: AnyObject | null\n}\n\nexport interface ES5ArrayState extends ES5BaseState {\n\ttype_: typeof ProxyTypeES5Array\n\tdraft_: Drafted<AnyObject, ES5ArrayState>\n\tbase_: any\n\tcopy_: any\n}\n\n/** Map / Set plugin */\n\nexport interface MapState extends ImmerBaseState {\n\ttype_: typeof ProxyTypeMap\n\tcopy_: AnyMap | undefined\n\tassigned_: Map<any, boolean> | undefined\n\tbase_: AnyMap\n\trevoked_: boolean\n\tdraft_: Drafted<AnyMap, MapState>\n}\n\nexport interface SetState extends ImmerBaseState {\n\ttype_: typeof ProxyTypeSet\n\tcopy_: AnySet | undefined\n\tbase_: AnySet\n\tdrafts_: Map<any, Drafted> // maps the original value to the draft value in the new set\n\trevoked_: boolean\n\tdraft_: Drafted<AnySet, SetState>\n}\n\n/** Patches plugin */\n\nexport type PatchPath = (string | number)[]\n","import {\n\tPatch,\n\tPatchListener,\n\tDrafted,\n\tImmer,\n\tDRAFT_STATE,\n\tImmerState,\n\tProxyTypeProxyObject,\n\tProxyTypeProxyArray,\n\tgetPlugin\n} from \"../internal\"\nimport {die} from \"../utils/errors\"\n\n/** Each scope represents a `produce` call. */\n\nexport interface ImmerScope {\n\tpatches_?: Patch[]\n\tinversePatches_?: Patch[]\n\tcanAutoFreeze_: boolean\n\tdrafts_: any[]\n\tparent_?: ImmerScope\n\tpatchListener_?: PatchListener\n\timmer_: Immer\n\tunfinalizedDrafts_: number\n}\n\nlet currentScope: ImmerScope | undefined\n\nexport function getCurrentScope() {\n\tif (__DEV__ && !currentScope) die(0)\n\treturn currentScope!\n}\n\nfunction createScope(\n\tparent_: ImmerScope | undefined,\n\timmer_: Immer\n): ImmerScope {\n\treturn {\n\t\tdrafts_: [],\n\t\tparent_,\n\t\timmer_,\n\t\t// Whenever the modified draft contains a draft from another scope, we\n\t\t// need to prevent auto-freezing so the unowned draft can be finalized.\n\t\tcanAutoFreeze_: true,\n\t\tunfinalizedDrafts_: 0\n\t}\n}\n\nexport function usePatchesInScope(\n\tscope: ImmerScope,\n\tpatchListener?: PatchListener\n) {\n\tif (patchListener) {\n\t\tgetPlugin(\"Patches\") // assert we have the plugin\n\t\tscope.patches_ = []\n\t\tscope.inversePatches_ = []\n\t\tscope.patchListener_ = patchListener\n\t}\n}\n\nexport function revokeScope(scope: ImmerScope) {\n\tleaveScope(scope)\n\tscope.drafts_.forEach(revokeDraft)\n\t// @ts-ignore\n\tscope.drafts_ = null\n}\n\nexport function leaveScope(scope: ImmerScope) {\n\tif (scope === currentScope) {\n\t\tcurrentScope = scope.parent_\n\t}\n}\n\nexport function enterScope(immer: Immer) {\n\treturn (currentScope = createScope(currentScope, immer))\n}\n\nfunction revokeDraft(draft: Drafted) {\n\tconst state: ImmerState = draft[DRAFT_STATE]\n\tif (\n\t\tstate.type_ === ProxyTypeProxyObject ||\n\t\tstate.type_ === ProxyTypeProxyArray\n\t)\n\t\tstate.revoke_()\n\telse state.revoked_ = true\n}\n","import {\n\tImmerScope,\n\tDRAFT_STATE,\n\tisDraftable,\n\tNOTHING,\n\tPatchPath,\n\teach,\n\thas,\n\tfreeze,\n\tImmerState,\n\tisDraft,\n\tSetState,\n\tset,\n\tProxyTypeES5Object,\n\tProxyTypeES5Array,\n\tProxyTypeSet,\n\tgetPlugin,\n\tdie,\n\trevokeScope,\n\tisFrozen,\n\tshallowCopy\n} from \"../internal\"\n\nexport function processResult(result: any, scope: ImmerScope) {\n\tscope.unfinalizedDrafts_ = scope.drafts_.length\n\tconst baseDraft = scope.drafts_![0]\n\tconst isReplaced = result !== undefined && result !== baseDraft\n\tif (!scope.immer_.useProxies_)\n\t\tgetPlugin(\"ES5\").willFinalizeES5_(scope, result, isReplaced)\n\tif (isReplaced) {\n\t\tif (baseDraft[DRAFT_STATE].modified_) {\n\t\t\trevokeScope(scope)\n\t\t\tdie(4)\n\t\t}\n\t\tif (isDraftable(result)) {\n\t\t\t// Finalize the result in case it contains (or is) a subset of the draft.\n\t\t\tresult = finalize(scope, result)\n\t\t\tif (!scope.parent_) maybeFreeze(scope, result)\n\t\t}\n\t\tif (scope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(\n\t\t\t\tbaseDraft[DRAFT_STATE],\n\t\t\t\tresult,\n\t\t\t\tscope.patches_,\n\t\t\t\tscope.inversePatches_!\n\t\t\t)\n\t\t}\n\t} else {\n\t\t// Finalize the base draft.\n\t\tresult = finalize(scope, baseDraft, [])\n\t}\n\trevokeScope(scope)\n\tif (scope.patches_) {\n\t\tscope.patchListener_!(scope.patches_, scope.inversePatches_!)\n\t}\n\treturn result !== NOTHING ? result : undefined\n}\n\nfunction finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {\n\t// Don't recurse in tho recursive data structures\n\tif (isFrozen(value)) return value\n\n\tconst state: ImmerState = value[DRAFT_STATE]\n\t// A plain object, might need freezing, might contain drafts\n\tif (!state) {\n\t\teach(\n\t\t\tvalue,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, value, key, childValue, path),\n\t\t\ttrue // See #590, don't recurse into non-enumarable of non drafted objects\n\t\t)\n\t\treturn value\n\t}\n\t// Never finalize drafts owned by another scope.\n\tif (state.scope_ !== rootScope) return value\n\t// Unmodified draft, return the (frozen) original\n\tif (!state.modified_) {\n\t\tmaybeFreeze(rootScope, state.base_, true)\n\t\treturn state.base_\n\t}\n\t// Not finalized yet, let's do that now\n\tif (!state.finalized_) {\n\t\tstate.finalized_ = true\n\t\tstate.scope_.unfinalizedDrafts_--\n\t\tconst result =\n\t\t\t// For ES5, create a good copy from the draft first, with added keys and without deleted keys.\n\t\t\tstate.type_ === ProxyTypeES5Object || state.type_ === ProxyTypeES5Array\n\t\t\t\t? (state.copy_ = shallowCopy(state.draft_))\n\t\t\t\t: state.copy_\n\t\t// Finalize all children of the copy\n\t\t// For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\n\t\t// Although the original test case doesn't seem valid anyway, so if this in the way we can turn the next line\n\t\t// back to each(result, ....)\n\t\teach(\n\t\t\tstate.type_ === ProxyTypeSet ? new Set(result) : result,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, result, key, childValue, path)\n\t\t)\n\t\t// everything inside is frozen, we can freeze here\n\t\tmaybeFreeze(rootScope, result, false)\n\t\t// first time finalizing, let's create those patches\n\t\tif (path && rootScope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generatePatches_(\n\t\t\t\tstate,\n\t\t\t\tpath,\n\t\t\t\trootScope.patches_,\n\t\t\t\trootScope.inversePatches_!\n\t\t\t)\n\t\t}\n\t}\n\treturn state.copy_\n}\n\nfunction finalizeProperty(\n\trootScope: ImmerScope,\n\tparentState: undefined | ImmerState,\n\ttargetObject: any,\n\tprop: string | number,\n\tchildValue: any,\n\trootPath?: PatchPath\n) {\n\tif (__DEV__ && childValue === targetObject) die(5)\n\tif (isDraft(childValue)) {\n\t\tconst path =\n\t\t\trootPath &&\n\t\t\tparentState &&\n\t\t\tparentState!.type_ !== ProxyTypeSet && // Set objects are atomic since they have no keys.\n\t\t\t!has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.\n\t\t\t\t? rootPath!.concat(prop)\n\t\t\t\t: undefined\n\t\t// Drafts owned by `scope` are finalized here.\n\t\tconst res = finalize(rootScope, childValue, path)\n\t\tset(targetObject, prop, res)\n\t\t// Drafts from another scope must prevented to be frozen\n\t\t// if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\n\t\tif (isDraft(res)) {\n\t\t\trootScope.canAutoFreeze_ = false\n\t\t} else return\n\t}\n\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n\tif (isDraftable(childValue) && !isFrozen(childValue)) {\n\t\tif (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n\t\t\t// optimization: if an object is not a draft, and we don't have to\n\t\t\t// deepfreeze everything, and we are sure that no drafts are left in the remaining object\n\t\t\t// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\n\t\t\t// This benefits especially adding large data tree's without further processing.\n\t\t\t// See add-data.js perf test\n\t\t\treturn\n\t\t}\n\t\tfinalize(rootScope, childValue)\n\t\t// immer deep freezes plain objects, so if there is no parent state, we freeze as well\n\t\tif (!parentState || !parentState.scope_.parent_)\n\t\t\tmaybeFreeze(rootScope, childValue)\n\t}\n}\n\nfunction maybeFreeze(scope: ImmerScope, value: any, deep = false) {\n\tif (scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n\t\tfreeze(value, deep)\n\t}\n}\n","import {\n\teach,\n\thas,\n\tis,\n\tisDraftable,\n\tshallowCopy,\n\tlatest,\n\tImmerBaseState,\n\tImmerState,\n\tDrafted,\n\tAnyObject,\n\tAnyArray,\n\tObjectish,\n\tgetCurrentScope,\n\tDRAFT_STATE,\n\tdie,\n\tcreateProxy,\n\tProxyTypeProxyObject,\n\tProxyTypeProxyArray\n} from \"../internal\"\n\ninterface ProxyBaseState extends ImmerBaseState {\n\tassigned_: {\n\t\t[property: string]: boolean\n\t}\n\tparent_?: ImmerState\n\trevoke_(): void\n}\n\nexport interface ProxyObjectState extends ProxyBaseState {\n\ttype_: typeof ProxyTypeProxyObject\n\tbase_: any\n\tcopy_: any\n\tdraft_: Drafted<AnyObject, ProxyObjectState>\n}\n\nexport interface ProxyArrayState extends ProxyBaseState {\n\ttype_: typeof ProxyTypeProxyArray\n\tbase_: AnyArray\n\tcopy_: AnyArray | null\n\tdraft_: Drafted<AnyArray, ProxyArrayState>\n}\n\ntype ProxyState = ProxyObjectState | ProxyArrayState\n\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\nexport function createProxyProxy<T extends Objectish>(\n\tbase: T,\n\tparent?: ImmerState\n): Drafted<T, ProxyState> {\n\tconst isArray = Array.isArray(base)\n\tconst state: ProxyState = {\n\t\ttype_: isArray ? ProxyTypeProxyArray : (ProxyTypeProxyObject as any),\n\t\t// Track which produce call this is associated with.\n\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t// True for both shallow and deep changes.\n\t\tmodified_: false,\n\t\t// Used during finalization.\n\t\tfinalized_: false,\n\t\t// Track which properties have been assigned (true) or deleted (false).\n\t\tassigned_: {},\n\t\t// The parent draft state.\n\t\tparent_: parent,\n\t\t// The base state.\n\t\tbase_: base,\n\t\t// The base proxy.\n\t\tdraft_: null as any, // set below\n\t\t// The base copy with any updated values.\n\t\tcopy_: null,\n\t\t// Called by the `produce` function.\n\t\trevoke_: null as any,\n\t\tisManual_: false\n\t}\n\n\t// the traps must target something, a bit like the 'real' base.\n\t// but also, we need to be able to determine from the target what the relevant state is\n\t// (to avoid creating traps per instance to capture the state in closure,\n\t// and to avoid creating weird hidden properties as well)\n\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\tlet target: T = state as any\n\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\n\tif (isArray) {\n\t\ttarget = [state] as any\n\t\ttraps = arrayTraps\n\t}\n\n\tconst {revoke, proxy} = Proxy.revocable(target, traps)\n\tstate.draft_ = proxy as any\n\tstate.revoke_ = revoke\n\treturn proxy as any\n}\n\n/**\n * Object drafts\n */\nexport const objectTraps: ProxyHandler<ProxyState> = {\n\tget(state, prop) {\n\t\tif (prop === DRAFT_STATE) return state\n\n\t\tconst source = latest(state)\n\t\tif (!has(source, prop)) {\n\t\t\t// non-existing or non-own property...\n\t\t\treturn readPropFromProto(state, source, prop)\n\t\t}\n\t\tconst value = source[prop]\n\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\t\t// Check for existing draft in modified state.\n\t\t// Assigned values are never drafted. This catches any drafts we created, too.\n\t\tif (value === peek(state.base_, prop)) {\n\t\t\tprepareCopy(state)\n\t\t\treturn (state.copy_![prop as any] = createProxy(\n\t\t\t\tstate.scope_.immer_,\n\t\t\t\tvalue,\n\t\t\t\tstate\n\t\t\t))\n\t\t}\n\t\treturn value\n\t},\n\thas(state, prop) {\n\t\treturn prop in latest(state)\n\t},\n\townKeys(state) {\n\t\treturn Reflect.ownKeys(latest(state))\n\t},\n\tset(state, prop: string /* strictly not, but helps TS */, value) {\n\t\tconst desc = getDescriptorFromProto(latest(state), prop)\n\t\tif (desc?.set) {\n\t\t\t// special case: if this write is captured by a setter, we have\n\t\t\t// to trigger it with the correct context\n\t\t\tdesc.set.call(state.draft_, value)\n\t\t\treturn true\n\t\t}\n\t\tstate.assigned_[prop] = true\n\t\tif (!state.modified_) {\n\t\t\t// the last check is because we need to be able to distinguish setting a non-existig to undefined (which is a change)\n\t\t\t// from setting an existing property with value undefined to undefined (which is not a change)\n\t\t\tif (\n\t\t\t\tis(value, peek(latest(state), prop)) &&\n\t\t\t\t(value !== undefined || has(state.base_, prop))\n\t\t\t)\n\t\t\t\treturn true\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t}\n\t\t// @ts-ignore\n\t\tstate.copy_![prop] = value\n\t\treturn true\n\t},\n\tdeleteProperty(state, prop: string) {\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (peek(state.base_, prop) !== undefined || prop in state.base_) {\n\t\t\tstate.assigned_[prop] = false\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t} else {\n\t\t\t// if an originally not assigned property was deleted\n\t\t\tdelete state.assigned_[prop]\n\t\t}\n\t\t// @ts-ignore\n\t\tif (state.copy_) delete state.copy_[prop]\n\t\treturn true\n\t},\n\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n\t// the same guarantee in ES5 mode.\n\tgetOwnPropertyDescriptor(state, prop) {\n\t\tconst owner = latest(state)\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\t\tif (!desc) return desc\n\t\treturn {\n\t\t\twritable: true,\n\t\t\tconfigurable: state.type_ !== ProxyTypeProxyArray || prop !== \"length\",\n\t\t\tenumerable: desc.enumerable,\n\t\t\tvalue: owner[prop]\n\t\t}\n\t},\n\tdefineProperty() {\n\t\tdie(11)\n\t},\n\tgetPrototypeOf(state) {\n\t\treturn Object.getPrototypeOf(state.base_)\n\t},\n\tsetPrototypeOf() {\n\t\tdie(12)\n\t}\n}\n\n/**\n * Array drafts\n */\n\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\neach(objectTraps, (key, fn) => {\n\t// @ts-ignore\n\tarrayTraps[key] = function() {\n\t\targuments[0] = arguments[0][0]\n\t\treturn fn.apply(this, arguments)\n\t}\n})\narrayTraps.deleteProperty = function(state, prop) {\n\tif (__DEV__ && isNaN(parseInt(prop as any))) die(13)\n\treturn objectTraps.deleteProperty!.call(this, state[0], prop)\n}\narrayTraps.set = function(state, prop, value) {\n\tif (__DEV__ && prop !== \"length\" && isNaN(parseInt(prop as any))) die(14)\n\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey) {\n\tconst state = draft[DRAFT_STATE]\n\tconst source = state ? latest(state) : draft\n\treturn source[prop]\n}\n\nfunction readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\n\tconst desc = getDescriptorFromProto(source, prop)\n\treturn desc\n\t\t? `value` in desc\n\t\t\t? desc.value\n\t\t\t: // This is a very special case, if the prop is a getter defined by the\n\t\t\t  // prototype, we should invoke it with the draft as context!\n\t\t\t  desc.get?.call(state.draft_)\n\t\t: undefined\n}\n\nfunction getDescriptorFromProto(\n\tsource: any,\n\tprop: PropertyKey\n): PropertyDescriptor | undefined {\n\t// 'in' checks proto!\n\tif (!(prop in source)) return undefined\n\tlet proto = Object.getPrototypeOf(source)\n\twhile (proto) {\n\t\tconst desc = Object.getOwnPropertyDescriptor(proto, prop)\n\t\tif (desc) return desc\n\t\tproto = Object.getPrototypeOf(proto)\n\t}\n\treturn undefined\n}\n\nexport function markChanged(state: ImmerState) {\n\tif (!state.modified_) {\n\t\tstate.modified_ = true\n\t\tif (state.parent_) {\n\t\t\tmarkChanged(state.parent_)\n\t\t}\n\t}\n}\n\nexport function prepareCopy(state: {base_: any; copy_: any}) {\n\tif (!state.copy_) {\n\t\tstate.copy_ = shallowCopy(state.base_)\n\t}\n}\n","import {\n\tIProduceWithPatches,\n\tIProduce,\n\tImmerState,\n\tDrafted,\n\tisDraftable,\n\tprocessResult,\n\tPatch,\n\tObjectish,\n\tDRAFT_STATE,\n\tDraft,\n\tPatchListener,\n\tisDraft,\n\tisMap,\n\tisSet,\n\tcreateProxyProxy,\n\tgetPlugin,\n\tdie,\n\thasProxies,\n\tisMinified,\n\tenterScope,\n\trevokeScope,\n\tleaveScope,\n\tusePatchesInScope,\n\tgetCurrentScope,\n\tNOTHING,\n\tfreeze,\n\tcurrent\n} from \"../internal\"\n\ninterface ProducersFns {\n\tproduce: IProduce\n\tproduceWithPatches: IProduceWithPatches\n}\n\nexport class Immer implements ProducersFns {\n\tuseProxies_: boolean = hasProxies\n\n\tautoFreeze_: boolean = __DEV__ ? true /* istanbul ignore next */ : !isMinified\n\n\tconstructor(config?: {useProxies?: boolean; autoFreeze?: boolean}) {\n\t\tif (typeof config?.useProxies === \"boolean\")\n\t\t\tthis.setUseProxies(config!.useProxies)\n\t\tif (typeof config?.autoFreeze === \"boolean\")\n\t\t\tthis.setAutoFreeze(config!.autoFreeze)\n\t\tthis.produce = this.produce.bind(this)\n\t\tthis.produceWithPatches = this.produceWithPatches.bind(this)\n\t}\n\n\t/**\n\t * The `produce` function takes a value and a \"recipe function\" (whose\n\t * return value often depends on the base state). The recipe function is\n\t * free to mutate its first argument however it wants. All mutations are\n\t * only ever applied to a __copy__ of the base state.\n\t *\n\t * Pass only a function to create a \"curried producer\" which relieves you\n\t * from passing the recipe function every time.\n\t *\n\t * Only plain objects and arrays are made mutable. All other objects are\n\t * considered uncopyable.\n\t *\n\t * Note: This function is __bound__ to its `Immer` instance.\n\t *\n\t * @param {any} base - the initial state\n\t * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\n\t * @returns {any} a new state, or the initial state if nothing was modified\n\t */\n\tproduce(base: any, recipe?: any, patchListener?: any) {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\" && typeof recipe !== \"function\") {\n\t\t\tconst defaultBase = recipe\n\t\t\trecipe = base\n\n\t\t\tconst self = this\n\t\t\treturn function curriedProduce(\n\t\t\t\tthis: any,\n\t\t\t\tbase = defaultBase,\n\t\t\t\t...args: any[]\n\t\t\t) {\n\t\t\t\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\tif (typeof recipe !== \"function\") die(6)\n\t\tif (patchListener !== undefined && typeof patchListener !== \"function\")\n\t\t\tdie(7)\n\n\t\tlet result\n\n\t\t// Only plain objects, arrays, and \"immerable classes\" are drafted.\n\t\tif (isDraftable(base)) {\n\t\t\tconst scope = enterScope(this)\n\t\t\tconst proxy = createProxy(this, base, undefined)\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// finally instead of catch + rethrow better preserves original stack\n\t\t\t\tif (hasError) revokeScope(scope)\n\t\t\t\telse leaveScope(scope)\n\t\t\t}\n\t\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\t\treturn result.then(\n\t\t\t\t\tresult => {\n\t\t\t\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\t\t\t\treturn processResult(result, scope)\n\t\t\t\t\t},\n\t\t\t\t\terror => {\n\t\t\t\t\t\trevokeScope(scope)\n\t\t\t\t\t\tthrow error\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\treturn processResult(result, scope)\n\t\t} else if (!base || typeof base !== \"object\") {\n\t\t\tresult = recipe(base)\n\t\t\tif (result === NOTHING) return undefined\n\t\t\tif (result === undefined) result = base\n\t\t\tif (this.autoFreeze_) freeze(result, true)\n\t\t\treturn result\n\t\t} else die(21, base)\n\t}\n\n\tproduceWithPatches(arg1: any, arg2?: any, arg3?: any): any {\n\t\tif (typeof arg1 === \"function\") {\n\t\t\treturn (state: any, ...args: any[]) =>\n\t\t\t\tthis.produceWithPatches(state, (draft: any) => arg1(draft, ...args))\n\t\t}\n\n\t\tlet patches: Patch[], inversePatches: Patch[]\n\t\tconst nextState = this.produce(arg1, arg2, (p: Patch[], ip: Patch[]) => {\n\t\t\tpatches = p\n\t\t\tinversePatches = ip\n\t\t})\n\t\treturn [nextState, patches!, inversePatches!]\n\t}\n\n\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\n\t\tif (!isDraftable(base)) die(8)\n\t\tif (isDraft(base)) base = current(base)\n\t\tconst scope = enterScope(this)\n\t\tconst proxy = createProxy(this, base, undefined)\n\t\tproxy[DRAFT_STATE].isManual_ = true\n\t\tleaveScope(scope)\n\t\treturn proxy as any\n\t}\n\n\tfinishDraft<D extends Draft<any>>(\n\t\tdraft: D,\n\t\tpatchListener?: PatchListener\n\t): D extends Draft<infer T> ? T : never {\n\t\tconst state: ImmerState = draft && (draft as any)[DRAFT_STATE]\n\t\tif (__DEV__) {\n\t\t\tif (!state || !state.isManual_) die(9)\n\t\t\tif (state.finalized_) die(10)\n\t\t}\n\t\tconst {scope_: scope} = state\n\t\tusePatchesInScope(scope, patchListener)\n\t\treturn processResult(undefined, scope)\n\t}\n\n\t/**\n\t * Pass true to automatically freeze all copies created by Immer.\n\t *\n\t * By default, auto-freezing is disabled in production.\n\t */\n\tsetAutoFreeze(value: boolean) {\n\t\tthis.autoFreeze_ = value\n\t}\n\n\t/**\n\t * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n\t * always faster than using ES5 proxies.\n\t *\n\t * By default, feature detection is used, so calling this is rarely necessary.\n\t */\n\tsetUseProxies(value: boolean) {\n\t\tif (value && !hasProxies) {\n\t\t\tdie(20)\n\t\t}\n\t\tthis.useProxies_ = value\n\t}\n\n\tapplyPatches(base: Objectish, patches: Patch[]) {\n\t\t// If a patch replaces the entire state, take that replacement as base\n\t\t// before applying patches\n\t\tlet i: number\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tconst applyPatchesImpl = getPlugin(\"Patches\").applyPatches_\n\t\tif (isDraft(base)) {\n\t\t\t// N.B: never hits if some patch a replacement, patches are never drafts\n\t\t\treturn applyPatchesImpl(base, patches)\n\t\t}\n\t\t// Otherwise, produce a copy of the base state.\n\t\treturn this.produce(base, (draft: Drafted) =>\n\t\t\tapplyPatchesImpl(draft, patches.slice(i + 1))\n\t\t)\n\t}\n}\n\nexport function createProxy<T extends Objectish>(\n\timmer: Immer,\n\tvalue: T,\n\tparent?: ImmerState\n): Drafted<T, ImmerState> {\n\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n\tconst draft: Drafted = isMap(value)\n\t\t? getPlugin(\"MapSet\").proxyMap_(value, parent)\n\t\t: isSet(value)\n\t\t? getPlugin(\"MapSet\").proxySet_(value, parent)\n\t\t: immer.useProxies_\n\t\t? createProxyProxy(value, parent)\n\t\t: getPlugin(\"ES5\").createES5Proxy_(value, parent)\n\n\tconst scope = parent ? parent.scope_ : getCurrentScope()\n\tscope.drafts_.push(draft)\n\treturn draft\n}\n","import {\n\tdie,\n\tisDraft,\n\tshallowCopy,\n\teach,\n\tDRAFT_STATE,\n\tget,\n\tset,\n\tImmerState,\n\tisDraftable,\n\tArchtypeMap,\n\tArchtypeSet,\n\tgetArchtype,\n\tgetPlugin\n} from \"../internal\"\n\n/** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */\nexport function current<T>(value: T): T\nexport function current(value: any): any {\n\tif (!isDraft(value)) die(22, value)\n\treturn currentImpl(value)\n}\n\nfunction currentImpl(value: any): any {\n\tif (!isDraftable(value)) return value\n\tconst state: ImmerState | undefined = value[DRAFT_STATE]\n\tlet copy: any\n\tconst archType = getArchtype(value)\n\tif (state) {\n\t\tif (\n\t\t\t!state.modified_ &&\n\t\t\t(state.type_ < 4 || !getPlugin(\"ES5\").hasChanges_(state as any))\n\t\t)\n\t\t\treturn state.base_\n\t\t// Optimization: avoid generating new drafts during copying\n\t\tstate.finalized_ = true\n\t\tcopy = copyHelper(value, archType)\n\t\tstate.finalized_ = false\n\t} else {\n\t\tcopy = copyHelper(value, archType)\n\t}\n\n\teach(copy, (key, childValue) => {\n\t\tif (state && get(state.base_, key) === childValue) return // no need to copy or search in something that didn't change\n\t\tset(copy, key, currentImpl(childValue))\n\t})\n\t// In the future, we might consider freezing here, based on the current settings\n\treturn archType === ArchtypeSet ? new Set(copy) : copy\n}\n\nfunction copyHelper(value: any, archType: number): any {\n\t// creates a shallow copy, even if it is a map or set\n\tswitch (archType) {\n\t\tcase ArchtypeMap:\n\t\t\treturn new Map(value)\n\t\tcase ArchtypeSet:\n\t\t\t// Set will be cloned as array temporarily, so that we can replace individual items\n\t\t\treturn Array.from(value)\n\t}\n\treturn shallowCopy(value)\n}\n","import {\n\tImmerState,\n\tDrafted,\n\tES5ArrayState,\n\tES5ObjectState,\n\teach,\n\thas,\n\tisDraft,\n\tlatest,\n\tDRAFT_STATE,\n\tis,\n\tloadPlugin,\n\tImmerScope,\n\tProxyTypeES5Array,\n\tProxyTypeES5Object,\n\tgetCurrentScope,\n\tdie,\n\tmarkChanged,\n\tobjectTraps,\n\townKeys,\n\tgetOwnPropertyDescriptors\n} from \"../internal\"\n\ntype ES5State = ES5ArrayState | ES5ObjectState\n\nexport function enableES5() {\n\tfunction willFinalizeES5_(\n\t\tscope: ImmerScope,\n\t\tresult: any,\n\t\tisReplaced: boolean\n\t) {\n\t\tif (!isReplaced) {\n\t\t\tif (scope.patches_) {\n\t\t\t\tmarkChangesRecursively(scope.drafts_![0])\n\t\t\t}\n\t\t\t// This is faster when we don't care about which attributes changed.\n\t\t\tmarkChangesSweep(scope.drafts_)\n\t\t}\n\t\t// When a child draft is returned, look for changes.\n\t\telse if (\n\t\t\tisDraft(result) &&\n\t\t\t(result[DRAFT_STATE] as ES5State).scope_ === scope\n\t\t) {\n\t\t\tmarkChangesSweep(scope.drafts_)\n\t\t}\n\t}\n\n\tfunction createES5Draft(isArray: boolean, base: any) {\n\t\tif (isArray) {\n\t\t\tconst draft = new Array(base.length)\n\t\t\tfor (let i = 0; i < base.length; i++)\n\t\t\t\tObject.defineProperty(draft, \"\" + i, proxyProperty(i, true))\n\t\t\treturn draft\n\t\t} else {\n\t\t\tconst descriptors = getOwnPropertyDescriptors(base)\n\t\t\tdelete descriptors[DRAFT_STATE as any]\n\t\t\tconst keys = ownKeys(descriptors)\n\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\tconst key: any = keys[i]\n\t\t\t\tdescriptors[key] = proxyProperty(\n\t\t\t\t\tkey,\n\t\t\t\t\tisArray || !!descriptors[key].enumerable\n\t\t\t\t)\n\t\t\t}\n\t\t\treturn Object.create(Object.getPrototypeOf(base), descriptors)\n\t\t}\n\t}\n\n\tfunction createES5Proxy_<T>(\n\t\tbase: T,\n\t\tparent?: ImmerState\n\t): Drafted<T, ES5ObjectState | ES5ArrayState> {\n\t\tconst isArray = Array.isArray(base)\n\t\tconst draft = createES5Draft(isArray, base)\n\n\t\tconst state: ES5ObjectState | ES5ArrayState = {\n\t\t\ttype_: isArray ? ProxyTypeES5Array : (ProxyTypeES5Object as any),\n\t\t\tscope_: parent ? parent.scope_ : getCurrentScope(),\n\t\t\tmodified_: false,\n\t\t\tfinalized_: false,\n\t\t\tassigned_: {},\n\t\t\tparent_: parent,\n\t\t\t// base is the object we are drafting\n\t\t\tbase_: base,\n\t\t\t// draft is the draft object itself, that traps all reads and reads from either the base (if unmodified) or copy (if modified)\n\t\t\tdraft_: draft,\n\t\t\tcopy_: null,\n\t\t\trevoked_: false,\n\t\t\tisManual_: false\n\t\t}\n\n\t\tObject.defineProperty(draft, DRAFT_STATE, {\n\t\t\tvalue: state,\n\t\t\t// enumerable: false <- the default\n\t\t\twritable: true\n\t\t})\n\t\treturn draft\n\t}\n\n\t// property descriptors are recycled to make sure we don't create a get and set closure per property,\n\t// but share them all instead\n\tconst descriptors: {[prop: string]: PropertyDescriptor} = {}\n\n\tfunction proxyProperty(\n\t\tprop: string | number,\n\t\tenumerable: boolean\n\t): PropertyDescriptor {\n\t\tlet desc = descriptors[prop]\n\t\tif (desc) {\n\t\t\tdesc.enumerable = enumerable\n\t\t} else {\n\t\t\tdescriptors[prop] = desc = {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable,\n\t\t\t\tget(this: any) {\n\t\t\t\t\tconst state = this[DRAFT_STATE]\n\t\t\t\t\tif (__DEV__) assertUnrevoked(state)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\treturn objectTraps.get(state, prop)\n\t\t\t\t},\n\t\t\t\tset(this: any, value) {\n\t\t\t\t\tconst state = this[DRAFT_STATE]\n\t\t\t\t\tif (__DEV__) assertUnrevoked(state)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tobjectTraps.set(state, prop, value)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn desc\n\t}\n\n\t// This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\n\tfunction markChangesSweep(drafts: Drafted<any, ImmerState>[]) {\n\t\t// The natural order of drafts in the `scope` array is based on when they\n\t\t// were accessed. By processing drafts in reverse natural order, we have a\n\t\t// better chance of processing leaf nodes first. When a leaf node is known to\n\t\t// have changed, we can avoid any traversal of its ancestor nodes.\n\t\tfor (let i = drafts.length - 1; i >= 0; i--) {\n\t\t\tconst state: ES5State = drafts[i][DRAFT_STATE]\n\t\t\tif (!state.modified_) {\n\t\t\t\tswitch (state.type_) {\n\t\t\t\t\tcase ProxyTypeES5Array:\n\t\t\t\t\t\tif (hasArrayChanges(state)) markChanged(state)\n\t\t\t\t\t\tbreak\n\t\t\t\t\tcase ProxyTypeES5Object:\n\t\t\t\t\t\tif (hasObjectChanges(state)) markChanged(state)\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction markChangesRecursively(object: any) {\n\t\tif (!object || typeof object !== \"object\") return\n\t\tconst state: ES5State | undefined = object[DRAFT_STATE]\n\t\tif (!state) return\n\t\tconst {base_, draft_, assigned_, type_} = state\n\t\tif (type_ === ProxyTypeES5Object) {\n\t\t\t// Look for added keys.\n\t\t\t// probably there is a faster way to detect changes, as sweep + recurse seems to do some\n\t\t\t// unnecessary work.\n\t\t\t// also: probably we can store the information we detect here, to speed up tree finalization!\n\t\t\teach(draft_, key => {\n\t\t\t\tif ((key as any) === DRAFT_STATE) return\n\t\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\t\tif ((base_ as any)[key] === undefined && !has(base_, key)) {\n\t\t\t\t\tassigned_[key] = true\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t} else if (!assigned_[key]) {\n\t\t\t\t\t// Only untouched properties trigger recursion.\n\t\t\t\t\tmarkChangesRecursively(draft_[key])\n\t\t\t\t}\n\t\t\t})\n\t\t\t// Look for removed keys.\n\t\t\teach(base_, key => {\n\t\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\t\tif (draft_[key] === undefined && !has(draft_, key)) {\n\t\t\t\t\tassigned_[key] = false\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t}\n\t\t\t})\n\t\t} else if (type_ === ProxyTypeES5Array) {\n\t\t\tif (hasArrayChanges(state as ES5ArrayState)) {\n\t\t\t\tmarkChanged(state)\n\t\t\t\tassigned_.length = true\n\t\t\t}\n\n\t\t\tif (draft_.length < base_.length) {\n\t\t\t\tfor (let i = draft_.length; i < base_.length; i++) assigned_[i] = false\n\t\t\t} else {\n\t\t\t\tfor (let i = base_.length; i < draft_.length; i++) assigned_[i] = true\n\t\t\t}\n\n\t\t\t// Minimum count is enough, the other parts has been processed.\n\t\t\tconst min = Math.min(draft_.length, base_.length)\n\n\t\t\tfor (let i = 0; i < min; i++) {\n\t\t\t\t// Only untouched indices trigger recursion.\n\t\t\t\tif (assigned_[i] === undefined) markChangesRecursively(draft_[i])\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction hasObjectChanges(state: ES5ObjectState) {\n\t\tconst {base_, draft_} = state\n\n\t\t// Search for added keys and changed keys. Start at the back, because\n\t\t// non-numeric keys are ordered by time of definition on the object.\n\t\tconst keys = ownKeys(draft_)\n\t\tfor (let i = keys.length - 1; i >= 0; i--) {\n\t\t\tconst key: any = keys[i]\n\t\t\tif (key === DRAFT_STATE) continue\n\t\t\tconst baseValue = base_[key]\n\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\tif (baseValue === undefined && !has(base_, key)) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\t// Once a base key is deleted, future changes go undetected, because its\n\t\t\t// descriptor is erased. This branch detects any missed changes.\n\t\t\telse {\n\t\t\t\tconst value = draft_[key]\n\t\t\t\tconst state: ImmerState = value && value[DRAFT_STATE]\n\t\t\t\tif (state ? state.base_ !== baseValue : !is(value, baseValue)) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// At this point, no keys were added or changed.\n\t\t// Compare key count to determine if keys were deleted.\n\t\tconst baseIsDraft = !!base_[DRAFT_STATE as any]\n\t\treturn keys.length !== ownKeys(base_).length + (baseIsDraft ? 0 : 1) // + 1 to correct for DRAFT_STATE\n\t}\n\n\tfunction hasArrayChanges(state: ES5ArrayState) {\n\t\tconst {draft_} = state\n\t\tif (draft_.length !== state.base_.length) return true\n\t\t// See #116\n\t\t// If we first shorten the length, our array interceptors will be removed.\n\t\t// If after that new items are added, result in the same original length,\n\t\t// those last items will have no intercepting property.\n\t\t// So if there is no own descriptor on the last position, we know that items were removed and added\n\t\t// N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n\t\t// the last one\n\t\tconst descriptor = Object.getOwnPropertyDescriptor(\n\t\t\tdraft_,\n\t\t\tdraft_.length - 1\n\t\t)\n\t\t// descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\t\tif (descriptor && !descriptor.get) return true\n\t\t// For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\t\treturn false\n\t}\n\n\tfunction hasChanges_(state: ES5State) {\n\t\treturn state.type_ === ProxyTypeES5Object\n\t\t\t? hasObjectChanges(state)\n\t\t\t: hasArrayChanges(state)\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tloadPlugin(\"ES5\", {\n\t\tcreateES5Proxy_,\n\t\twillFinalizeES5_,\n\t\thasChanges_\n\t})\n}\n","import {\n\tIProduce,\n\tIProduceWithPatches,\n\tImmer,\n\tDraft,\n\tImmutable\n} from \"./internal\"\n\nexport {\n\tDraft,\n\tImmutable,\n\tPatch,\n\tPatchListener,\n\toriginal,\n\tcurrent,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable\n} from \"./internal\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce: IProduce = immer.produce\nexport default produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * By default, auto-freezing is disabled in production.\n */\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\nexport const setUseProxies = immer.setUseProxies.bind(immer)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = immer.finishDraft.bind(immer)\n\n/**\n * This function is actually a no-op, but can be used to cast an immutable type\n * to an draft type and make TypeScript happy\n *\n * @param value\n */\nexport function castDraft<T>(value: T): Draft<T> {\n\treturn value as any\n}\n\n/**\n * This function is actually a no-op, but can be used to cast a mutable type\n * to an immutable type and make TypeScript happy\n * @param value\n */\nexport function castImmutable<T>(value: T): Immutable<T> {\n\treturn value as any\n}\n\nexport {Immer}\n\nexport {enableES5} from \"./plugins/es5\"\nexport {enablePatches} from \"./plugins/patches\"\nexport {enableMapSet} from \"./plugins/mapset\"\nexport {enableAllPlugins} from \"./plugins/all\"\n","// Should be no imports here!\n\n// Some things that should be evaluated before all else...\n\n// We only want to know if non-polyfilled symbols are available\nconst hasSymbol =\n\ttypeof Symbol !== \"undefined\" && typeof Symbol(\"x\") === \"symbol\"\nexport const hasMap = typeof Map !== \"undefined\"\nexport const hasSet = typeof Set !== \"undefined\"\nexport const hasProxies =\n\ttypeof Proxy !== \"undefined\" &&\n\ttypeof Proxy.revocable !== \"undefined\" &&\n\ttypeof Reflect !== \"undefined\"\n\n/* istanbul ignore next */\nfunction mini() {}\nexport const isMinified = mini.name !== \"mini\"\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: Nothing = hasSymbol\n\t? Symbol.for(\"immer-nothing\")\n\t: ({[\"immer-nothing\"]: true} as any)\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-draftable\")\n\t: (\"__$immer_draftable\" as any)\n\nexport const DRAFT_STATE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-state\")\n\t: (\"__$immer_state\" as any)\n\n// Even a polyfilled Symbol might provide Symbol.iterator\nexport const iteratorSymbol: typeof Symbol.iterator =\n\t(typeof Symbol != \"undefined\" && Symbol.iterator) || (\"@@iterator\" as any)\n\n/** Use a class type for `nothing` so its type is unique */\nexport class Nothing {\n\t// This lets us do `Exclude<T, Nothing>`\n\t// @ts-ignore\n\tprivate _!: unique symbol\n}\n","import $$observable from 'symbol-observable';\n\n/**\n * These are private action types reserved by Redux.\n * For any unknown actions, you must return the current state.\n * If the current state is undefined, you must return the initial state.\n * Do not reference these action types directly in your code.\n */\nvar randomString = function randomString() {\n  return Math.random().toString(36).substring(7).split('').join('.');\n};\n\nvar ActionTypes = {\n  INIT: \"@@redux/INIT\" + randomString(),\n  REPLACE: \"@@redux/REPLACE\" + randomString(),\n  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {\n    return \"@@redux/PROBE_UNKNOWN_ACTION\" + randomString();\n  }\n};\n\n/**\n * @param {any} obj The object to inspect.\n * @returns {boolean} True if the argument appears to be a plain object.\n */\nfunction isPlainObject(obj) {\n  if (typeof obj !== 'object' || obj === null) return false;\n  var proto = obj;\n\n  while (Object.getPrototypeOf(proto) !== null) {\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return Object.getPrototypeOf(obj) === proto;\n}\n\n/**\n * Creates a Redux store that holds the state tree.\n * The only way to change the data in the store is to call `dispatch()` on it.\n *\n * There should only be a single store in your app. To specify how different\n * parts of the state tree respond to actions, you may combine several reducers\n * into a single reducer function by using `combineReducers`.\n *\n * @param {Function} reducer A function that returns the next state tree, given\n * the current state tree and the action to handle.\n *\n * @param {any} [preloadedState] The initial state. You may optionally specify it\n * to hydrate the state from the server in universal apps, or to restore a\n * previously serialized user session.\n * If you use `combineReducers` to produce the root reducer function, this must be\n * an object with the same shape as `combineReducers` keys.\n *\n * @param {Function} [enhancer] The store enhancer. You may optionally specify it\n * to enhance the store with third-party capabilities such as middleware,\n * time travel, persistence, etc. The only store enhancer that ships with Redux\n * is `applyMiddleware()`.\n *\n * @returns {Store} A Redux store that lets you read the state, dispatch actions\n * and subscribe to changes.\n */\n\nfunction createStore(reducer, preloadedState, enhancer) {\n  var _ref2;\n\n  if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {\n    throw new Error('It looks like you are passing several store enhancers to ' + 'createStore(). This is not supported. Instead, compose them ' + 'together to a single function.');\n  }\n\n  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\n    enhancer = preloadedState;\n    preloadedState = undefined;\n  }\n\n  if (typeof enhancer !== 'undefined') {\n    if (typeof enhancer !== 'function') {\n      throw new Error('Expected the enhancer to be a function.');\n    }\n\n    return enhancer(createStore)(reducer, preloadedState);\n  }\n\n  if (typeof reducer !== 'function') {\n    throw new Error('Expected the reducer to be a function.');\n  }\n\n  var currentReducer = reducer;\n  var currentState = preloadedState;\n  var currentListeners = [];\n  var nextListeners = currentListeners;\n  var isDispatching = false;\n  /**\n   * This makes a shallow copy of currentListeners so we can use\n   * nextListeners as a temporary list while dispatching.\n   *\n   * This prevents any bugs around consumers calling\n   * subscribe/unsubscribe in the middle of a dispatch.\n   */\n\n  function ensureCanMutateNextListeners() {\n    if (nextListeners === currentListeners) {\n      nextListeners = currentListeners.slice();\n    }\n  }\n  /**\n   * Reads the state tree managed by the store.\n   *\n   * @returns {any} The current state tree of your application.\n   */\n\n\n  function getState() {\n    if (isDispatching) {\n      throw new Error('You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');\n    }\n\n    return currentState;\n  }\n  /**\n   * Adds a change listener. It will be called any time an action is dispatched,\n   * and some part of the state tree may potentially have changed. You may then\n   * call `getState()` to read the current state tree inside the callback.\n   *\n   * You may call `dispatch()` from a change listener, with the following\n   * caveats:\n   *\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\n   * will not have any effect on the `dispatch()` that is currently in progress.\n   * However, the next `dispatch()` call, whether nested or not, will use a more\n   * recent snapshot of the subscription list.\n   *\n   * 2. The listener should not expect to see all state changes, as the state\n   * might have been updated multiple times during a nested `dispatch()` before\n   * the listener is called. It is, however, guaranteed that all subscribers\n   * registered before the `dispatch()` started will be called with the latest\n   * state by the time it exits.\n   *\n   * @param {Function} listener A callback to be invoked on every dispatch.\n   * @returns {Function} A function to remove this change listener.\n   */\n\n\n  function subscribe(listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('Expected the listener to be a function.');\n    }\n\n    if (isDispatching) {\n      throw new Error('You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api-reference/store#subscribelistener for more details.');\n    }\n\n    var isSubscribed = true;\n    ensureCanMutateNextListeners();\n    nextListeners.push(listener);\n    return function unsubscribe() {\n      if (!isSubscribed) {\n        return;\n      }\n\n      if (isDispatching) {\n        throw new Error('You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api-reference/store#subscribelistener for more details.');\n      }\n\n      isSubscribed = false;\n      ensureCanMutateNextListeners();\n      var index = nextListeners.indexOf(listener);\n      nextListeners.splice(index, 1);\n      currentListeners = null;\n    };\n  }\n  /**\n   * Dispatches an action. It is the only way to trigger a state change.\n   *\n   * The `reducer` function, used to create the store, will be called with the\n   * current state tree and the given `action`. Its return value will\n   * be considered the **next** state of the tree, and the change listeners\n   * will be notified.\n   *\n   * The base implementation only supports plain object actions. If you want to\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\n   * wrap your store creating function into the corresponding middleware. For\n   * example, see the documentation for the `redux-thunk` package. Even the\n   * middleware will eventually dispatch plain object actions using this method.\n   *\n   * @param {Object} action A plain object representing what changed. It is\n   * a good idea to keep actions serializable so you can record and replay user\n   * sessions, or use the time travelling `redux-devtools`. An action must have\n   * a `type` property which may not be `undefined`. It is a good idea to use\n   * string constants for action types.\n   *\n   * @returns {Object} For convenience, the same action object you dispatched.\n   *\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\n   * return something else (for example, a Promise you can await).\n   */\n\n\n  function dispatch(action) {\n    if (!isPlainObject(action)) {\n      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');\n    }\n\n    if (typeof action.type === 'undefined') {\n      throw new Error('Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?');\n    }\n\n    if (isDispatching) {\n      throw new Error('Reducers may not dispatch actions.');\n    }\n\n    try {\n      isDispatching = true;\n      currentState = currentReducer(currentState, action);\n    } finally {\n      isDispatching = false;\n    }\n\n    var listeners = currentListeners = nextListeners;\n\n    for (var i = 0; i < listeners.length; i++) {\n      var listener = listeners[i];\n      listener();\n    }\n\n    return action;\n  }\n  /**\n   * Replaces the reducer currently used by the store to calculate the state.\n   *\n   * You might need this if your app implements code splitting and you want to\n   * load some of the reducers dynamically. You might also need this if you\n   * implement a hot reloading mechanism for Redux.\n   *\n   * @param {Function} nextReducer The reducer for the store to use instead.\n   * @returns {void}\n   */\n\n\n  function replaceReducer(nextReducer) {\n    if (typeof nextReducer !== 'function') {\n      throw new Error('Expected the nextReducer to be a function.');\n    }\n\n    currentReducer = nextReducer; // This action has a similiar effect to ActionTypes.INIT.\n    // Any reducers that existed in both the new and old rootReducer\n    // will receive the previous state. This effectively populates\n    // the new state tree with any relevant data from the old one.\n\n    dispatch({\n      type: ActionTypes.REPLACE\n    });\n  }\n  /**\n   * Interoperability point for observable/reactive libraries.\n   * @returns {observable} A minimal observable of state changes.\n   * For more information, see the observable proposal:\n   * https://github.com/tc39/proposal-observable\n   */\n\n\n  function observable() {\n    var _ref;\n\n    var outerSubscribe = subscribe;\n    return _ref = {\n      /**\n       * The minimal observable subscription method.\n       * @param {Object} observer Any object that can be used as an observer.\n       * The observer object should have a `next` method.\n       * @returns {subscription} An object with an `unsubscribe` method that can\n       * be used to unsubscribe the observable from the store, and prevent further\n       * emission of values from the observable.\n       */\n      subscribe: function subscribe(observer) {\n        if (typeof observer !== 'object' || observer === null) {\n          throw new TypeError('Expected the observer to be an object.');\n        }\n\n        function observeState() {\n          if (observer.next) {\n            observer.next(getState());\n          }\n        }\n\n        observeState();\n        var unsubscribe = outerSubscribe(observeState);\n        return {\n          unsubscribe: unsubscribe\n        };\n      }\n    }, _ref[$$observable] = function () {\n      return this;\n    }, _ref;\n  } // When a store is created, an \"INIT\" action is dispatched so that every\n  // reducer returns their initial state. This effectively populates\n  // the initial state tree.\n\n\n  dispatch({\n    type: ActionTypes.INIT\n  });\n  return _ref2 = {\n    dispatch: dispatch,\n    subscribe: subscribe,\n    getState: getState,\n    replaceReducer: replaceReducer\n  }, _ref2[$$observable] = observable, _ref2;\n}\n\n/**\n * Prints a warning in the console if it exists.\n *\n * @param {String} message The warning message.\n * @returns {void}\n */\nfunction warning(message) {\n  /* eslint-disable no-console */\n  if (typeof console !== 'undefined' && typeof console.error === 'function') {\n    console.error(message);\n  }\n  /* eslint-enable no-console */\n\n\n  try {\n    // This error was thrown as a convenience so that if you enable\n    // \"break on all exceptions\" in your console,\n    // it would pause the execution at this line.\n    throw new Error(message);\n  } catch (e) {} // eslint-disable-line no-empty\n\n}\n\nfunction getUndefinedStateErrorMessage(key, action) {\n  var actionType = action && action.type;\n  var actionDescription = actionType && \"action \\\"\" + String(actionType) + \"\\\"\" || 'an action';\n  return \"Given \" + actionDescription + \", reducer \\\"\" + key + \"\\\" returned undefined. \" + \"To ignore an action, you must explicitly return the previous state. \" + \"If you want this reducer to hold no value, you can return null instead of undefined.\";\n}\n\nfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\n  var reducerKeys = Object.keys(reducers);\n  var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';\n\n  if (reducerKeys.length === 0) {\n    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';\n  }\n\n  if (!isPlainObject(inputState)) {\n    return \"The \" + argumentName + \" has unexpected type of \\\"\" + {}.toString.call(inputState).match(/\\s([a-z|A-Z]+)/)[1] + \"\\\". Expected argument to be an object with the following \" + (\"keys: \\\"\" + reducerKeys.join('\", \"') + \"\\\"\");\n  }\n\n  var unexpectedKeys = Object.keys(inputState).filter(function (key) {\n    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];\n  });\n  unexpectedKeys.forEach(function (key) {\n    unexpectedKeyCache[key] = true;\n  });\n  if (action && action.type === ActionTypes.REPLACE) return;\n\n  if (unexpectedKeys.length > 0) {\n    return \"Unexpected \" + (unexpectedKeys.length > 1 ? 'keys' : 'key') + \" \" + (\"\\\"\" + unexpectedKeys.join('\", \"') + \"\\\" found in \" + argumentName + \". \") + \"Expected to find one of the known reducer keys instead: \" + (\"\\\"\" + reducerKeys.join('\", \"') + \"\\\". Unexpected keys will be ignored.\");\n  }\n}\n\nfunction assertReducerShape(reducers) {\n  Object.keys(reducers).forEach(function (key) {\n    var reducer = reducers[key];\n    var initialState = reducer(undefined, {\n      type: ActionTypes.INIT\n    });\n\n    if (typeof initialState === 'undefined') {\n      throw new Error(\"Reducer \\\"\" + key + \"\\\" returned undefined during initialization. \" + \"If the state passed to the reducer is undefined, you must \" + \"explicitly return the initial state. The initial state may \" + \"not be undefined. If you don't want to set a value for this reducer, \" + \"you can use null instead of undefined.\");\n    }\n\n    if (typeof reducer(undefined, {\n      type: ActionTypes.PROBE_UNKNOWN_ACTION()\n    }) === 'undefined') {\n      throw new Error(\"Reducer \\\"\" + key + \"\\\" returned undefined when probed with a random type. \" + (\"Don't try to handle \" + ActionTypes.INIT + \" or other actions in \\\"redux/*\\\" \") + \"namespace. They are considered private. Instead, you must return the \" + \"current state for any unknown actions, unless it is undefined, \" + \"in which case you must return the initial state, regardless of the \" + \"action type. The initial state may not be undefined, but can be null.\");\n    }\n  });\n}\n/**\n * Turns an object whose values are different reducer functions, into a single\n * reducer function. It will call every child reducer, and gather their results\n * into a single state object, whose keys correspond to the keys of the passed\n * reducer functions.\n *\n * @param {Object} reducers An object whose values correspond to different\n * reducer functions that need to be combined into one. One handy way to obtain\n * it is to use ES6 `import * as reducers` syntax. The reducers may never return\n * undefined for any action. Instead, they should return their initial state\n * if the state passed to them was undefined, and the current state for any\n * unrecognized action.\n *\n * @returns {Function} A reducer function that invokes every reducer inside the\n * passed object, and builds a state object with the same shape.\n */\n\n\nfunction combineReducers(reducers) {\n  var reducerKeys = Object.keys(reducers);\n  var finalReducers = {};\n\n  for (var i = 0; i < reducerKeys.length; i++) {\n    var key = reducerKeys[i];\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof reducers[key] === 'undefined') {\n        warning(\"No reducer provided for key \\\"\" + key + \"\\\"\");\n      }\n    }\n\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key];\n    }\n  }\n\n  var finalReducerKeys = Object.keys(finalReducers); // This is used to make sure we don't warn about the same\n  // keys multiple times.\n\n  var unexpectedKeyCache;\n\n  if (process.env.NODE_ENV !== 'production') {\n    unexpectedKeyCache = {};\n  }\n\n  var shapeAssertionError;\n\n  try {\n    assertReducerShape(finalReducers);\n  } catch (e) {\n    shapeAssertionError = e;\n  }\n\n  return function combination(state, action) {\n    if (state === void 0) {\n      state = {};\n    }\n\n    if (shapeAssertionError) {\n      throw shapeAssertionError;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);\n\n      if (warningMessage) {\n        warning(warningMessage);\n      }\n    }\n\n    var hasChanged = false;\n    var nextState = {};\n\n    for (var _i = 0; _i < finalReducerKeys.length; _i++) {\n      var _key = finalReducerKeys[_i];\n      var reducer = finalReducers[_key];\n      var previousStateForKey = state[_key];\n      var nextStateForKey = reducer(previousStateForKey, action);\n\n      if (typeof nextStateForKey === 'undefined') {\n        var errorMessage = getUndefinedStateErrorMessage(_key, action);\n        throw new Error(errorMessage);\n      }\n\n      nextState[_key] = nextStateForKey;\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n    }\n\n    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;\n    return hasChanged ? nextState : state;\n  };\n}\n\nfunction bindActionCreator(actionCreator, dispatch) {\n  return function () {\n    return dispatch(actionCreator.apply(this, arguments));\n  };\n}\n/**\n * Turns an object whose values are action creators, into an object with the\n * same keys, but with every function wrapped into a `dispatch` call so they\n * may be invoked directly. This is just a convenience method, as you can call\n * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.\n *\n * For convenience, you can also pass an action creator as the first argument,\n * and get a dispatch wrapped function in return.\n *\n * @param {Function|Object} actionCreators An object whose values are action\n * creator functions. One handy way to obtain it is to use ES6 `import * as`\n * syntax. You may also pass a single function.\n *\n * @param {Function} dispatch The `dispatch` function available on your Redux\n * store.\n *\n * @returns {Function|Object} The object mimicking the original object, but with\n * every action creator wrapped into the `dispatch` call. If you passed a\n * function as `actionCreators`, the return value will also be a single\n * function.\n */\n\n\nfunction bindActionCreators(actionCreators, dispatch) {\n  if (typeof actionCreators === 'function') {\n    return bindActionCreator(actionCreators, dispatch);\n  }\n\n  if (typeof actionCreators !== 'object' || actionCreators === null) {\n    throw new Error(\"bindActionCreators expected an object or a function, instead received \" + (actionCreators === null ? 'null' : typeof actionCreators) + \". \" + \"Did you write \\\"import ActionCreators from\\\" instead of \\\"import * as ActionCreators from\\\"?\");\n  }\n\n  var boundActionCreators = {};\n\n  for (var key in actionCreators) {\n    var actionCreator = actionCreators[key];\n\n    if (typeof actionCreator === 'function') {\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\n    }\n  }\n\n  return boundActionCreators;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    keys.push.apply(keys, Object.getOwnPropertySymbols(object));\n  }\n\n  if (enumerableOnly) keys = keys.filter(function (sym) {\n    return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n  });\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\n/**\n * Composes single-argument functions from right to left. The rightmost\n * function can take multiple arguments as it provides the signature for\n * the resulting composite function.\n *\n * @param {...Function} funcs The functions to compose.\n * @returns {Function} A function obtained by composing the argument functions\n * from right to left. For example, compose(f, g, h) is identical to doing\n * (...args) => f(g(h(...args))).\n */\nfunction compose() {\n  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n\n  if (funcs.length === 0) {\n    return function (arg) {\n      return arg;\n    };\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n\n  return funcs.reduce(function (a, b) {\n    return function () {\n      return a(b.apply(void 0, arguments));\n    };\n  });\n}\n\n/**\n * Creates a store enhancer that applies middleware to the dispatch method\n * of the Redux store. This is handy for a variety of tasks, such as expressing\n * asynchronous actions in a concise manner, or logging every action payload.\n *\n * See `redux-thunk` package as an example of the Redux middleware.\n *\n * Because middleware is potentially asynchronous, this should be the first\n * store enhancer in the composition chain.\n *\n * Note that each middleware will be given the `dispatch` and `getState` functions\n * as named arguments.\n *\n * @param {...Function} middlewares The middleware chain to be applied.\n * @returns {Function} A store enhancer applying the middleware.\n */\n\nfunction applyMiddleware() {\n  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {\n    middlewares[_key] = arguments[_key];\n  }\n\n  return function (createStore) {\n    return function () {\n      var store = createStore.apply(void 0, arguments);\n\n      var _dispatch = function dispatch() {\n        throw new Error('Dispatching while constructing your middleware is not allowed. ' + 'Other middleware would not be applied to this dispatch.');\n      };\n\n      var middlewareAPI = {\n        getState: store.getState,\n        dispatch: function dispatch() {\n          return _dispatch.apply(void 0, arguments);\n        }\n      };\n      var chain = middlewares.map(function (middleware) {\n        return middleware(middlewareAPI);\n      });\n      _dispatch = compose.apply(void 0, chain)(store.dispatch);\n      return _objectSpread2({}, store, {\n        dispatch: _dispatch\n      });\n    };\n  };\n}\n\n/*\n * This is a dummy function to check if the function name has been altered by minification.\n * If the function has been minified and NODE_ENV !== 'production', warn the user.\n */\n\nfunction isCrushed() {}\n\nif (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {\n  warning('You are currently using minified code outside of NODE_ENV === \"production\". ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) ' + 'to ensure you have the correct code for your production build.');\n}\n\nexport { ActionTypes as __DO_NOT_USE__ActionTypes, applyMiddleware, bindActionCreators, combineReducers, compose, createStore };\n","function defaultEqualityCheck(a, b) {\n  return a === b;\n}\n\nfunction areArgumentsShallowlyEqual(equalityCheck, prev, next) {\n  if (prev === null || next === null || prev.length !== next.length) {\n    return false;\n  }\n\n  // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.\n  var length = prev.length;\n  for (var i = 0; i < length; i++) {\n    if (!equalityCheck(prev[i], next[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function defaultMemoize(func) {\n  var equalityCheck = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultEqualityCheck;\n\n  var lastArgs = null;\n  var lastResult = null;\n  // we reference arguments instead of spreading them for performance reasons\n  return function () {\n    if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {\n      // apply arguments instead of spreading for performance.\n      lastResult = func.apply(null, arguments);\n    }\n\n    lastArgs = arguments;\n    return lastResult;\n  };\n}\n\nfunction getDependencies(funcs) {\n  var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;\n\n  if (!dependencies.every(function (dep) {\n    return typeof dep === 'function';\n  })) {\n    var dependencyTypes = dependencies.map(function (dep) {\n      return typeof dep;\n    }).join(', ');\n    throw new Error('Selector creators expect all input-selectors to be functions, ' + ('instead received the following types: [' + dependencyTypes + ']'));\n  }\n\n  return dependencies;\n}\n\nexport function createSelectorCreator(memoize) {\n  for (var _len = arguments.length, memoizeOptions = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    memoizeOptions[_key - 1] = arguments[_key];\n  }\n\n  return function () {\n    for (var _len2 = arguments.length, funcs = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      funcs[_key2] = arguments[_key2];\n    }\n\n    var recomputations = 0;\n    var resultFunc = funcs.pop();\n    var dependencies = getDependencies(funcs);\n\n    var memoizedResultFunc = memoize.apply(undefined, [function () {\n      recomputations++;\n      // apply arguments instead of spreading for performance.\n      return resultFunc.apply(null, arguments);\n    }].concat(memoizeOptions));\n\n    // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.\n    var selector = memoize(function () {\n      var params = [];\n      var length = dependencies.length;\n\n      for (var i = 0; i < length; i++) {\n        // apply arguments instead of spreading and mutate a local list of params for performance.\n        params.push(dependencies[i].apply(null, arguments));\n      }\n\n      // apply arguments instead of spreading for performance.\n      return memoizedResultFunc.apply(null, params);\n    });\n\n    selector.resultFunc = resultFunc;\n    selector.dependencies = dependencies;\n    selector.recomputations = function () {\n      return recomputations;\n    };\n    selector.resetRecomputations = function () {\n      return recomputations = 0;\n    };\n    return selector;\n  };\n}\n\nexport var createSelector = createSelectorCreator(defaultMemoize);\n\nexport function createStructuredSelector(selectors) {\n  var selectorCreator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : createSelector;\n\n  if (typeof selectors !== 'object') {\n    throw new Error('createStructuredSelector expects first argument to be an object ' + ('where each property is a selector, instead received a ' + typeof selectors));\n  }\n  var objectKeys = Object.keys(selectors);\n  return selectorCreator(objectKeys.map(function (key) {\n    return selectors[key];\n  }), function () {\n    for (var _len3 = arguments.length, values = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      values[_key3] = arguments[_key3];\n    }\n\n    return values.reduce(function (composition, value, index) {\n      composition[objectKeys[index]] = value;\n      return composition;\n    }, {});\n  });\n}","function createThunkMiddleware(extraArgument) {\n  return function (_ref) {\n    var dispatch = _ref.dispatch,\n        getState = _ref.getState;\n    return function (next) {\n      return function (action) {\n        if (typeof action === 'function') {\n          return action(dispatch, getState, extraArgument);\n        }\n\n        return next(action);\n      };\n    };\n  };\n}\n\nvar thunk = createThunkMiddleware();\nthunk.withExtraArgument = createThunkMiddleware;\n\nexport default thunk;","import { Action, ActionCreator, StoreEnhancer, compose } from 'redux'\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface EnhancerOptions {\r\n  /**\r\n   * the instance name to be showed on the monitor page. Default value is `document.title`.\r\n   * If not specified and there's no document title, it will consist of `tabId` and `instanceId`.\r\n   */\r\n  name?: string\r\n  /**\r\n   * action creators functions to be available in the Dispatcher.\r\n   */\r\n  actionCreators?: ActionCreator<any>[] | { [key: string]: ActionCreator<any> }\r\n  /**\r\n   * if more than one action is dispatched in the indicated interval, all new actions will be collected and sent at once.\r\n   * It is the joint between performance and speed. When set to `0`, all actions will be sent instantly.\r\n   * Set it to a higher value when experiencing perf issues (also `maxAge` to a lower value).\r\n   *\r\n   * @default 500 ms.\r\n   */\r\n  latency?: number\r\n  /**\r\n   * (> 1) - maximum allowed actions to be stored in the history tree. The oldest actions are removed once maxAge is reached. It's critical for performance.\r\n   *\r\n   * @default 50\r\n   */\r\n  maxAge?: number\r\n  /**\r\n   * - `undefined` - will use regular `JSON.stringify` to send data (it's the fast mode).\r\n   * - `false` - will handle also circular references.\r\n   * - `true` - will handle also date, regex, undefined, error objects, symbols, maps, sets and functions.\r\n   * - object, which contains `date`, `regex`, `undefined`, `error`, `symbol`, `map`, `set` and `function` keys.\r\n   *   For each of them you can indicate if to include (by setting as `true`).\r\n   *   For `function` key you can also specify a custom function which handles serialization.\r\n   *   See [`jsan`](https://github.com/kolodny/jsan) for more details.\r\n   */\r\n  serialize?:\r\n    | boolean\r\n    | {\r\n        date?: boolean\r\n        regex?: boolean\r\n        undefined?: boolean\r\n        error?: boolean\r\n        symbol?: boolean\r\n        map?: boolean\r\n        set?: boolean\r\n        function?: boolean | Function\r\n      }\r\n  /**\r\n   * function which takes `action` object and id number as arguments, and should return `action` object back.\r\n   */\r\n  actionSanitizer?: <A extends Action>(action: A, id: number) => A\r\n  /**\r\n   * function which takes `state` object and index as arguments, and should return `state` object back.\r\n   */\r\n  stateSanitizer?: <S>(state: S, index: number) => S\r\n  /**\r\n   * *string or array of strings as regex* - actions types to be hidden / shown in the monitors (while passed to the reducers).\r\n   * If `actionsWhitelist` specified, `actionsBlacklist` is ignored.\r\n   */\r\n  actionsBlacklist?: string | string[]\r\n  /**\r\n   * *string or array of strings as regex* - actions types to be hidden / shown in the monitors (while passed to the reducers).\r\n   * If `actionsWhitelist` specified, `actionsBlacklist` is ignored.\r\n   */\r\n  actionsWhitelist?: string | string[]\r\n  /**\r\n   * called for every action before sending, takes `state` and `action` object, and returns `true` in case it allows sending the current data to the monitor.\r\n   * Use it as a more advanced version of `actionsBlacklist`/`actionsWhitelist` parameters.\r\n   */\r\n  predicate?: <S, A extends Action>(state: S, action: A) => boolean\r\n  /**\r\n   * if specified as `false`, it will not record the changes till clicking on `Start recording` button.\r\n   * Available only for Redux enhancer, for others use `autoPause`.\r\n   *\r\n   * @default true\r\n   */\r\n  shouldRecordChanges?: boolean\r\n  /**\r\n   * if specified, whenever clicking on `Pause recording` button and there are actions in the history log, will add this action type.\r\n   * If not specified, will commit when paused. Available only for Redux enhancer.\r\n   *\r\n   * @default \"@@PAUSED\"\"\r\n   */\r\n  pauseActionType?: string\r\n  /**\r\n   * auto pauses when the extensions window is not opened, and so has zero impact on your app when not in use.\r\n   * Not available for Redux enhancer (as it already does it but storing the data to be sent).\r\n   *\r\n   * @default false\r\n   */\r\n  autoPause?: boolean\r\n  /**\r\n   * if specified as `true`, it will not allow any non-monitor actions to be dispatched till clicking on `Unlock changes` button.\r\n   * Available only for Redux enhancer.\r\n   *\r\n   * @default false\r\n   */\r\n  shouldStartLocked?: boolean\r\n  /**\r\n   * if set to `false`, will not recompute the states on hot reloading (or on replacing the reducers). Available only for Redux enhancer.\r\n   *\r\n   * @default true\r\n   */\r\n  shouldHotReload?: boolean\r\n  /**\r\n   * if specified as `true`, whenever there's an exception in reducers, the monitors will show the error message, and next actions will not be dispatched.\r\n   *\r\n   * @default false\r\n   */\r\n  shouldCatchErrors?: boolean\r\n  /**\r\n   * If you want to restrict the extension, specify the features you allow.\r\n   * If not specified, all of the features are enabled. When set as an object, only those included as `true` will be allowed.\r\n   * Note that except `true`/`false`, `import` and `export` can be set as `custom` (which is by default for Redux enhancer), meaning that the importing/exporting occurs on the client side.\r\n   * Otherwise, you'll get/set the data right from the monitor part.\r\n   */\r\n  features?: {\r\n    /**\r\n     * start/pause recording of dispatched actions\r\n     */\r\n    pause?: boolean\r\n    /**\r\n     * lock/unlock dispatching actions and side effects\r\n     */\r\n    lock?: boolean\r\n    /**\r\n     * persist states on page reloading\r\n     */\r\n    persist?: boolean\r\n    /**\r\n     * export history of actions in a file\r\n     */\r\n    export?: boolean | 'custom'\r\n    /**\r\n     * import history of actions from a file\r\n     */\r\n    import?: boolean | 'custom'\r\n    /**\r\n     * jump back and forth (time travelling)\r\n     */\r\n    jump?: boolean\r\n    /**\r\n     * skip (cancel) actions\r\n     */\r\n    skip?: boolean\r\n    /**\r\n     * drag and drop actions in the history list\r\n     */\r\n    reorder?: boolean\r\n    /**\r\n     * dispatch custom actions or action creators\r\n     */\r\n    dispatch?: boolean\r\n    /**\r\n     * generate tests for the selected actions\r\n     */\r\n    test?: boolean\r\n  }\r\n  /**\r\n   * Set to true or a stacktrace-returning function to record call stack traces for dispatched actions.\r\n   * Defaults to false.\r\n   */\r\n  trace?: boolean | (<A extends Action>(action: A) => string)\r\n  /**\r\n   * The maximum number of stack trace entries to record per action. Defaults to 10.\r\n   */\r\n  traceLimit?: number\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport const composeWithDevTools: {\r\n  (options: EnhancerOptions): typeof compose\r\n  <StoreExt>(...funcs: Array<StoreEnhancer<StoreExt>>): StoreEnhancer<StoreExt>\r\n} =\r\n  typeof window !== 'undefined' &&\r\n  (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\r\n    ? (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\r\n    : function() {\r\n        if (arguments.length === 0) return undefined\r\n        if (typeof arguments[0] === 'object') return compose\r\n        return compose.apply(null, (arguments as any) as Function[])\r\n      }\r\n\r\n/**\r\n * @public\r\n */\r\nexport const devToolsEnhancer: {\r\n  (options: EnhancerOptions): StoreEnhancer<any>\r\n} =\r\n  typeof window !== 'undefined' && (window as any).__REDUX_DEVTOOLS_EXTENSION__\r\n    ? (window as any).__REDUX_DEVTOOLS_EXTENSION__\r\n    : function() {\r\n        return function(noop) {\r\n          return noop\r\n        }\r\n      }\r\n","import { Action } from 'redux'\r\nimport {\r\n  IsUnknownOrNonInferrable,\r\n  IfMaybeUndefined,\r\n  IfVoid,\r\n  IsAny\r\n} from './tsHelpers'\r\nimport isPlainObject from './isPlainObject'\r\n\r\n/**\r\n * An action with a string type and an associated payload. This is the\r\n * type of action returned by `createAction()` action creators.\r\n *\r\n * @template P The type of the action's payload.\r\n * @template T the type used for the action type.\r\n * @template M The type of the action's meta (optional)\r\n * @template E The type of the action's error (optional)\r\n *\r\n * @public\r\n */\r\nexport type PayloadAction<\r\n  P = void,\r\n  T extends string = string,\r\n  M = never,\r\n  E = never\r\n> = {\r\n  payload: P\r\n  type: T\r\n} & ([M] extends [never]\r\n  ? {}\r\n  : {\r\n      meta: M\r\n    }) &\r\n  ([E] extends [never]\r\n    ? {}\r\n    : {\r\n        error: E\r\n      })\r\n\r\n/**\r\n * A \"prepare\" method to be used as the second parameter of `createAction`.\r\n * Takes any number of arguments and returns a Flux Standard Action without\r\n * type (will be added later) that *must* contain a payload (might be undefined).\r\n *\r\n * @public\r\n */\r\nexport type PrepareAction<P> =\r\n  | ((...args: any[]) => { payload: P })\r\n  | ((...args: any[]) => { payload: P; meta: any })\r\n  | ((...args: any[]) => { payload: P; error: any })\r\n  | ((...args: any[]) => { payload: P; meta: any; error: any })\r\n\r\n/**\r\n * Internal version of `ActionCreatorWithPreparedPayload`. Not to be used externally.\r\n *\r\n * @internal\r\n */\r\nexport type _ActionCreatorWithPreparedPayload<\r\n  PA extends PrepareAction<any> | void,\r\n  T extends string = string\r\n> = PA extends PrepareAction<infer P>\r\n  ? ActionCreatorWithPreparedPayload<\r\n      Parameters<PA>,\r\n      P,\r\n      T,\r\n      ReturnType<PA> extends {\r\n        error: infer E\r\n      }\r\n        ? E\r\n        : never,\r\n      ReturnType<PA> extends {\r\n        meta: infer M\r\n      }\r\n        ? M\r\n        : never\r\n    >\r\n  : void\r\n\r\n/**\r\n * Basic type for all action creators.\r\n *\r\n * @inheritdoc {redux#ActionCreator}\r\n */\r\ninterface BaseActionCreator<P, T extends string, M = never, E = never> {\r\n  type: T\r\n  match(action: Action<unknown>): action is PayloadAction<P, T, M, E>\r\n}\r\n\r\n/**\r\n * An action creator that takes multiple arguments that are passed\r\n * to a `PrepareAction` method to create the final Action.\r\n * @typeParam Args arguments for the action creator function\r\n * @typeParam P `payload` type\r\n * @typeParam T `type` name\r\n * @typeParam E optional `error` type\r\n * @typeParam M optional `meta` type\r\n *\r\n * @inheritdoc {redux#ActionCreator}\r\n *\r\n * @public\r\n */\r\nexport interface ActionCreatorWithPreparedPayload<\r\n  Args extends unknown[],\r\n  P,\r\n  T extends string = string,\r\n  E = never,\r\n  M = never\r\n> extends BaseActionCreator<P, T, M, E> {\r\n  /**\r\n   * Calling this {@link redux#ActionCreator} with `Args` will return\r\n   * an Action with a payload of type `P` and (depending on the `PrepareAction`\r\n   * method used) a `meta`- and `error` property of types `M` and `E` respectively.\r\n   */\r\n  (...args: Args): PayloadAction<P, T, M, E>\r\n}\r\n\r\n/**\r\n * An action creator of type `T` that takes an optional payload of type `P`.\r\n *\r\n * @inheritdoc {redux#ActionCreator}\r\n *\r\n * @public\r\n */\r\nexport interface ActionCreatorWithOptionalPayload<P, T extends string = string>\r\n  extends BaseActionCreator<P, T> {\r\n  /**\r\n   * Calling this {@link redux#ActionCreator} with an argument will\r\n   * return a {@link PayloadAction} of type `T` with a payload of `P`.\r\n   * Calling it without an argument will return a PayloadAction with a payload of `undefined`.\r\n   */\r\n  (payload?: P): PayloadAction<P, T>\r\n}\r\n\r\n/**\r\n * An action creator of type `T` that takes no payload.\r\n *\r\n * @inheritdoc {redux#ActionCreator}\r\n *\r\n * @public\r\n */\r\nexport interface ActionCreatorWithoutPayload<T extends string = string>\r\n  extends BaseActionCreator<undefined, T> {\r\n  /**\r\n   * Calling this {@link redux#ActionCreator} will\r\n   * return a {@link PayloadAction} of type `T` with a payload of `undefined`\r\n   */\r\n  (): PayloadAction<undefined, T>\r\n}\r\n\r\n/**\r\n * An action creator of type `T` that requires a payload of type P.\r\n *\r\n * @inheritdoc {redux#ActionCreator}\r\n *\r\n * @public\r\n */\r\nexport interface ActionCreatorWithPayload<P, T extends string = string>\r\n  extends BaseActionCreator<P, T> {\r\n  /**\r\n   * Calling this {@link redux#ActionCreator} with an argument will\r\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\r\n   */\r\n  (payload: P): PayloadAction<P, T>\r\n}\r\n\r\n/**\r\n * An action creator of type `T` whose `payload` type could not be inferred. Accepts everything as `payload`.\r\n *\r\n * @inheritdoc {redux#ActionCreator}\r\n *\r\n * @public\r\n */\r\nexport interface ActionCreatorWithNonInferrablePayload<\r\n  T extends string = string\r\n> extends BaseActionCreator<unknown, T> {\r\n  /**\r\n   * Calling this {@link redux#ActionCreator} with an argument will\r\n   * return a {@link PayloadAction} of type `T` with a payload\r\n   * of exactly the type of the argument.\r\n   */\r\n  <PT extends unknown>(payload: PT): PayloadAction<PT, T>\r\n}\r\n\r\n/**\r\n * An action creator that produces actions with a `payload` attribute.\r\n *\r\n * @typeParam P the `payload` type\r\n * @typeParam T the `type` of the resulting action\r\n * @typeParam PA if the resulting action is preprocessed by a `prepare` method, the signature of said method.\r\n *\r\n * @public\r\n */\r\nexport type PayloadActionCreator<\r\n  P = void,\r\n  T extends string = string,\r\n  PA extends PrepareAction<P> | void = void\r\n> = IfPrepareActionMethodProvided<\r\n  PA,\r\n  _ActionCreatorWithPreparedPayload<PA, T>,\r\n  // else\r\n  IsAny<\r\n    P,\r\n    ActionCreatorWithPayload<any, T>,\r\n    IsUnknownOrNonInferrable<\r\n      P,\r\n      ActionCreatorWithNonInferrablePayload<T>,\r\n      // else\r\n      IfVoid<\r\n        P,\r\n        ActionCreatorWithoutPayload<T>,\r\n        // else\r\n        IfMaybeUndefined<\r\n          P,\r\n          ActionCreatorWithOptionalPayload<P, T>,\r\n          // else\r\n          ActionCreatorWithPayload<P, T>\r\n        >\r\n      >\r\n    >\r\n  >\r\n>\r\n\r\n/**\r\n * A utility function to create an action creator for the given action type\r\n * string. The action creator accepts a single argument, which will be included\r\n * in the action object as a field called payload. The action creator function\r\n * will also have its toString() overriden so that it returns the action type,\r\n * allowing it to be used in reducer logic that is looking for that action type.\r\n *\r\n * @param type The action type to use for created actions.\r\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\r\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\r\n *\r\n * @public\r\n */\r\nexport function createAction<P = void, T extends string = string>(\r\n  type: T\r\n): PayloadActionCreator<P, T>\r\n\r\n/**\r\n * A utility function to create an action creator for the given action type\r\n * string. The action creator accepts a single argument, which will be included\r\n * in the action object as a field called payload. The action creator function\r\n * will also have its toString() overriden so that it returns the action type,\r\n * allowing it to be used in reducer logic that is looking for that action type.\r\n *\r\n * @param type The action type to use for created actions.\r\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\r\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\r\n *\r\n * @public\r\n */\r\nexport function createAction<\r\n  PA extends PrepareAction<any>,\r\n  T extends string = string\r\n>(\r\n  type: T,\r\n  prepareAction: PA\r\n): PayloadActionCreator<ReturnType<PA>['payload'], T, PA>\r\n\r\nexport function createAction(type: string, prepareAction?: Function): any {\r\n  function actionCreator(...args: any[]) {\r\n    if (prepareAction) {\r\n      let prepared = prepareAction(...args)\r\n      if (!prepared) {\r\n        throw new Error('prepareAction did not return an object')\r\n      }\r\n\r\n      return {\r\n        type,\r\n        payload: prepared.payload,\r\n        ...('meta' in prepared && { meta: prepared.meta }),\r\n        ...('error' in prepared && { error: prepared.error })\r\n      }\r\n    }\r\n    return { type, payload: args[0] }\r\n  }\r\n\r\n  actionCreator.toString = () => `${type}`\r\n\r\n  actionCreator.type = type\r\n\r\n  actionCreator.match = (action: Action<unknown>): action is PayloadAction =>\r\n    action.type === type\r\n\r\n  return actionCreator\r\n}\r\n\r\nexport function isFSA(\r\n  action: unknown\r\n): action is {\r\n  type: string\r\n  payload?: unknown\r\n  error?: unknown\r\n  meta?: unknown\r\n} {\r\n  return (\r\n    isPlainObject(action) &&\r\n    typeof (action as any).type === 'string' &&\r\n    Object.keys(action).every(isValidKey)\r\n  )\r\n}\r\n\r\nfunction isValidKey(key: string) {\r\n  return ['type', 'payload', 'error', 'meta'].indexOf(key) > -1\r\n}\r\n\r\n/**\r\n * Returns the action type of the actions created by the passed\r\n * `createAction()`-generated action creator (arbitrary action creators\r\n * are not supported).\r\n *\r\n * @param action The action creator whose action type to get.\r\n * @returns The action type used by the action creator.\r\n *\r\n * @public\r\n */\r\nexport function getType<T extends string>(\r\n  actionCreator: PayloadActionCreator<any, T>\r\n): T {\r\n  return `${actionCreator}` as T\r\n}\r\n\r\n// helper types for more readable typings\r\n\r\ntype IfPrepareActionMethodProvided<\r\n  PA extends PrepareAction<any> | void,\r\n  True,\r\n  False\r\n> = PA extends (...args: any[]) => any ? True : False\r\n","import { Action, AnyAction } from 'redux'\r\nimport {\r\n  CaseReducer,\r\n  CaseReducers,\r\n  ActionMatcher,\r\n  ActionMatcherDescriptionCollection\r\n} from './createReducer'\r\n\r\nexport interface TypedActionCreator<Type extends string> {\r\n  (...args: any[]): Action<Type>\r\n  type: Type\r\n}\r\n\r\n/**\r\n * A builder for an action <-> reducer map.\r\n *\r\n * @public\r\n */\r\nexport interface ActionReducerMapBuilder<State> {\r\n  /**\r\n   * Add a case reducer for actions created by this action creator.\r\n   * @param actionCreator\r\n   * @param reducer\r\n   */\r\n  addCase<ActionCreator extends TypedActionCreator<string>>(\r\n    actionCreator: ActionCreator,\r\n    reducer: CaseReducer<State, ReturnType<ActionCreator>>\r\n  ): ActionReducerMapBuilder<State>\r\n  /**\r\n   * Add a case reducer for actions with the specified type.\r\n   * @param type\r\n   * @param reducer\r\n   */\r\n  addCase<Type extends string, A extends Action<Type>>(\r\n    type: Type,\r\n    reducer: CaseReducer<State, A>\r\n  ): ActionReducerMapBuilder<State>\r\n\r\n  /**\r\n   * Adds a reducer for all actions, using `matcher` as a filter function.\r\n   * If multiple matcher reducers match, all of them will be executed in the order\r\n   * they were defined if - even if a case reducer already matched.\r\n   * @param matcher A matcher function. In TypeScript, this should be a [type predicate](https://www.typescriptlang.org/docs/handbook/advanced-types.html#using-type-predicates)\r\n   *   function\r\n   * @param reducer\r\n   */\r\n  addMatcher<A extends AnyAction>(\r\n    matcher: ActionMatcher<A>,\r\n    reducer: CaseReducer<State, A>\r\n  ): Omit<ActionReducerMapBuilder<State>, 'addCase'>\r\n\r\n  /**\r\n   * Adds a \"default case\" reducer that is executed if no case reducer and no matcher\r\n   * reducer was executed for this action.\r\n   * @param reducer\r\n   */\r\n  addDefaultCase(reducer: CaseReducer<State, AnyAction>): {}\r\n}\r\n\r\nexport function executeReducerBuilderCallback<S>(\r\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\r\n): [\r\n  CaseReducers<S, any>,\r\n  ActionMatcherDescriptionCollection<S>,\r\n  CaseReducer<S, AnyAction> | undefined\r\n] {\r\n  const actionsMap: CaseReducers<S, any> = {}\r\n  const actionMatchers: ActionMatcherDescriptionCollection<S> = []\r\n  let defaultCaseReducer: CaseReducer<S, AnyAction> | undefined\r\n  const builder = {\r\n    addCase(\r\n      typeOrActionCreator: string | TypedActionCreator<any>,\r\n      reducer: CaseReducer<S>\r\n    ) {\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        /*\r\n         to keep the definition by the user in line with actual behavior, \r\n         we enforce `addCase` to always be called before calling `addMatcher`\r\n         as matching cases take precedence over matchers\r\n         */\r\n        if (actionMatchers.length > 0) {\r\n          throw new Error(\r\n            '`builder.addCase` should only be called before calling `builder.addMatcher`'\r\n          )\r\n        }\r\n        if (defaultCaseReducer) {\r\n          throw new Error(\r\n            '`builder.addCase` should only be called before calling `builder.addDefaultCase`'\r\n          )\r\n        }\r\n      }\r\n      const type =\r\n        typeof typeOrActionCreator === 'string'\r\n          ? typeOrActionCreator\r\n          : typeOrActionCreator.type\r\n      if (type in actionsMap) {\r\n        throw new Error(\r\n          'addCase cannot be called with two reducers for the same action type'\r\n        )\r\n      }\r\n      actionsMap[type] = reducer\r\n      return builder\r\n    },\r\n    addMatcher<A extends AnyAction>(\r\n      matcher: ActionMatcher<A>,\r\n      reducer: CaseReducer<S, A>\r\n    ) {\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        if (defaultCaseReducer) {\r\n          throw new Error(\r\n            '`builder.addMatcher` should only be called before calling `builder.addDefaultCase`'\r\n          )\r\n        }\r\n      }\r\n      actionMatchers.push({ matcher, reducer })\r\n      return builder\r\n    },\r\n    addDefaultCase(reducer: CaseReducer<S, AnyAction>) {\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        if (defaultCaseReducer) {\r\n          throw new Error('`builder.addDefaultCase` can only be called once')\r\n        }\r\n      }\r\n      defaultCaseReducer = reducer\r\n      return builder\r\n    }\r\n  }\r\n  builderCallback(builder)\r\n  return [actionsMap, actionMatchers, defaultCaseReducer]\r\n}\r\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { enableES5 } from 'immer'\r\nexport * from 'redux'\r\nexport { default as createNextState, Draft, current } from 'immer'\r\nexport {\r\n  createSelector,\r\n  Selector,\r\n  OutputParametricSelector,\r\n  OutputSelector,\r\n  ParametricSelector\r\n} from 'reselect'\r\nexport { ThunkAction, ThunkDispatch } from 'redux-thunk'\r\n\r\n// We deliberately enable Immer's ES5 support, on the grounds that\r\n// we assume RTK will be used with React Native and other Proxy-less\r\n// environments.  In addition, that's how Immer 4 behaved, and since\r\n// we want to ship this in an RTK minor, we should keep the same behavior.\r\nenableES5()\r\n\r\nexport {\r\n  // js\r\n  configureStore,\r\n  // types\r\n  ConfigureEnhancersCallback,\r\n  ConfigureStoreOptions,\r\n  EnhancedStore\r\n} from './configureStore'\r\nexport {\r\n  // js\r\n  createAction,\r\n  getType,\r\n  // types\r\n  PayloadAction,\r\n  PayloadActionCreator,\r\n  ActionCreatorWithNonInferrablePayload,\r\n  ActionCreatorWithOptionalPayload,\r\n  ActionCreatorWithPayload,\r\n  ActionCreatorWithoutPayload,\r\n  ActionCreatorWithPreparedPayload,\r\n  PrepareAction\r\n} from './createAction'\r\nexport {\r\n  // js\r\n  createReducer,\r\n  // types\r\n  Actions,\r\n  CaseReducer,\r\n  CaseReducers\r\n} from './createReducer'\r\nexport {\r\n  // js\r\n  createSlice,\r\n  // types\r\n  CreateSliceOptions,\r\n  Slice,\r\n  CaseReducerActions,\r\n  SliceCaseReducers,\r\n  ValidateSliceCaseReducers,\r\n  CaseReducerWithPrepare,\r\n  SliceActionCreator\r\n} from './createSlice'\r\nexport {\r\n  // js\r\n  createImmutableStateInvariantMiddleware,\r\n  isImmutableDefault,\r\n  // types\r\n  ImmutableStateInvariantMiddlewareOptions\r\n} from './immutableStateInvariantMiddleware'\r\nexport {\r\n  // js\r\n  createSerializableStateInvariantMiddleware,\r\n  findNonSerializableValue,\r\n  isPlain,\r\n  // types\r\n  SerializableStateInvariantMiddlewareOptions\r\n} from './serializableStateInvariantMiddleware'\r\nexport {\r\n  // js\r\n  getDefaultMiddleware\r\n} from './getDefaultMiddleware'\r\nexport {\r\n  // types\r\n  ActionReducerMapBuilder\r\n} from './mapBuilders'\r\nexport { MiddlewareArray } from './utils'\r\n\r\nexport { createEntityAdapter } from './entities/create_adapter'\r\nexport {\r\n  Dictionary,\r\n  EntityState,\r\n  EntityAdapter,\r\n  EntitySelectors,\r\n  EntityStateAdapter,\r\n  EntityId,\r\n  Update,\r\n  IdSelector,\r\n  Comparer\r\n} from './entities/models'\r\n\r\nexport {\r\n  AsyncThunk,\r\n  AsyncThunkAction,\r\n  AsyncThunkPayloadCreatorReturnValue,\r\n  AsyncThunkPayloadCreator,\r\n  createAsyncThunk,\r\n  unwrapResult,\r\n  SerializedError\r\n} from './createAsyncThunk'\r\n\r\nexport { nanoid } from './nanoid'\r\n","import { createSlice, PayloadAction } from '@reduxjs/toolkit';\n\nimport { createNewGame, checkSolution } from 'utils';\nimport { Grid, N, Block, FilledBlock, NewGame, difficultyLevel } from 'types';\n\ninterface GridState {\n  solvedGrid: Grid;\n  challengeGrid: Grid;\n  activeGrid: Grid;\n  selectedBlock: Block | null;\n  moves: number;\n  actualRemainingBlocks: number;\n  remainingBlocks: number;\n  loading: boolean;\n  hideClues: boolean;\n  victoryModalOpen: boolean;\n  difficulty: difficultyLevel;\n}\n\ntype CREATE_NEW_GAME_IN_WORKER = 'CREATE_NEW_GAME_IN_WORKER';\nconst CREATE_NEW_GAME_IN_WORKER = 'CREATE_NEW_GAME_IN_WORKER';\n\nexport interface NewGameWorkerAction {\n  type: CREATE_NEW_GAME_IN_WORKER;\n  worker: boolean;\n  successActionType: string;\n}\n\nconst initialState: GridState = {\n  ...createNewGame(),\n  selectedBlock: null,\n  difficulty: 'easy',\n  loading: false,\n  hideClues: false,\n  victoryModalOpen: false,\n  moves: 0,\n};\n\nconst gridSlice = createSlice({\n  name: 'grid',\n  initialState,\n  reducers: {\n    startNewGame(state, action: PayloadAction<NewGame>) {\n      const {\n        activeGrid,\n        solvedGrid,\n        challengeGrid,\n        remainingBlocks,\n        actualRemainingBlocks,\n      } = action.payload;\n\n      state.activeGrid = activeGrid;\n      state.solvedGrid = solvedGrid;\n      state.challengeGrid = challengeGrid;\n      state.actualRemainingBlocks = actualRemainingBlocks;\n      state.remainingBlocks = remainingBlocks;\n      state.moves = 0;\n      state.loading = false;\n      state.selectedBlock = null;\n      state.victoryModalOpen = false;\n    },\n    resetGame(state) {\n      state.activeGrid = state.challengeGrid;\n      state.remainingBlocks = state.actualRemainingBlocks;\n      state.moves = 0;\n      state.selectedBlock = null;\n      state.victoryModalOpen = false;\n    },\n    selectBlock(state, action: PayloadAction<Block>) {\n      state.selectedBlock = action.payload;\n    },\n    setDifficulty(state, action: PayloadAction<difficultyLevel>) {\n      state.difficulty = action.payload;\n    },\n    closeModal(state) {\n      state.victoryModalOpen = false;\n    },\n    startLoading(state) {\n      state.loading = true;\n    },\n    toggleHideClues(state) {\n      state.hideClues = !state.hideClues;\n    },\n    fillBlock(\n      state,\n      { payload: { row, col, value } }: PayloadAction<FilledBlock>\n    ) {\n      const previousValue = state.activeGrid[row][col];\n      if (!previousValue) {\n        state.remainingBlocks--;\n      }\n      if (value !== previousValue && !state.victoryModalOpen) {\n        state.moves++;\n      }\n\n      state.activeGrid[row][col] = value as N;\n      if (!state.remainingBlocks) {\n        const isCorrect = checkSolution(state.activeGrid, state.solvedGrid);\n        if (isCorrect) {\n          state.victoryModalOpen = true;\n        }\n      }\n    },\n  },\n});\n\nconst newGameFromWorker = (): NewGameWorkerAction => {\n  return {\n    type: CREATE_NEW_GAME_IN_WORKER,\n    worker: true,\n    successActionType: gridSlice.actions.startNewGame.toString(),\n  };\n};\nnewGameFromWorker.toString = () => CREATE_NEW_GAME_IN_WORKER;\nexport { newGameFromWorker };\n\nexport const {\n  actions: {\n    startNewGame,\n    selectBlock,\n    fillBlock,\n    resetGame,\n    startLoading,\n    setDifficulty,\n    closeModal,\n    toggleHideClues,\n  },\n  reducer: gridReducer,\n} = gridSlice;\n","import { Reducer } from 'redux'\r\nimport {\r\n  ActionCreatorWithoutPayload,\r\n  createAction,\r\n  PayloadAction,\r\n  PayloadActionCreator,\r\n  PrepareAction,\r\n  _ActionCreatorWithPreparedPayload\r\n} from './createAction'\r\nimport { CaseReducer, CaseReducers, createReducer } from './createReducer'\r\nimport {\r\n  ActionReducerMapBuilder,\r\n  executeReducerBuilderCallback\r\n} from './mapBuilders'\r\nimport { Omit, NoInfer } from './tsHelpers'\r\n\r\n/**\r\n * An action creator attached to a slice.\r\n *\r\n * @deprecated please use PayloadActionCreator directly\r\n *\r\n * @public\r\n */\r\nexport type SliceActionCreator<P> = PayloadActionCreator<P>\r\n\r\n/**\r\n * The return value of `createSlice`\r\n *\r\n * @public\r\n */\r\nexport interface Slice<\r\n  State = any,\r\n  CaseReducers extends SliceCaseReducers<State> = SliceCaseReducers<State>,\r\n  Name extends string = string\r\n> {\r\n  /**\r\n   * The slice name.\r\n   */\r\n  name: Name\r\n\r\n  /**\r\n   * The slice's reducer.\r\n   */\r\n  reducer: Reducer<State>\r\n\r\n  /**\r\n   * Action creators for the types of actions that are handled by the slice\r\n   * reducer.\r\n   */\r\n  actions: CaseReducerActions<CaseReducers>\r\n\r\n  /**\r\n   * The individual case reducer functions that were passed in the `reducers` parameter.\r\n   * This enables reuse and testing if they were defined inline when calling `createSlice`.\r\n   */\r\n  caseReducers: SliceDefinedCaseReducers<CaseReducers>\r\n}\r\n\r\n/**\r\n * Options for `createSlice()`.\r\n *\r\n * @public\r\n */\r\nexport interface CreateSliceOptions<\r\n  State = any,\r\n  CR extends SliceCaseReducers<State> = SliceCaseReducers<State>,\r\n  Name extends string = string\r\n> {\r\n  /**\r\n   * The slice's name. Used to namespace the generated action types.\r\n   */\r\n  name: Name\r\n\r\n  /**\r\n   * The initial state to be returned by the slice reducer.\r\n   */\r\n  initialState: State\r\n\r\n  /**\r\n   * A mapping from action types to action-type-specific *case reducer*\r\n   * functions. For every action type, a matching action creator will be\r\n   * generated using `createAction()`.\r\n   */\r\n  reducers: ValidateSliceCaseReducers<State, CR>\r\n\r\n  /**\r\n   * A mapping from action types to action-type-specific *case reducer*\r\n   * functions. These reducers should have existing action types used\r\n   * as the keys, and action creators will _not_ be generated.\r\n   * Alternatively, a callback that receives a *builder* object to define\r\n   * case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\r\n   */\r\n  extraReducers?:\r\n    | CaseReducers<NoInfer<State>, any>\r\n    | ((builder: ActionReducerMapBuilder<NoInfer<State>>) => void)\r\n}\r\n\r\n/**\r\n * A CaseReducer with a `prepare` method.\r\n *\r\n * @public\r\n */\r\nexport type CaseReducerWithPrepare<State, Action extends PayloadAction> = {\r\n  reducer: CaseReducer<State, Action>\r\n  prepare: PrepareAction<Action['payload']>\r\n}\r\n\r\n/**\r\n * The type describing a slice's `reducers` option.\r\n *\r\n * @public\r\n */\r\nexport type SliceCaseReducers<State> = {\r\n  [K: string]:\r\n    | CaseReducer<State, PayloadAction<any>>\r\n    | CaseReducerWithPrepare<State, PayloadAction<any, string, any, any>>\r\n}\r\n\r\n/**\r\n * Derives the slice's `actions` property from the `reducers` options\r\n *\r\n * @public\r\n */\r\nexport type CaseReducerActions<CaseReducers extends SliceCaseReducers<any>> = {\r\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends { prepare: any }\r\n    ? ActionCreatorForCaseReducerWithPrepare<CaseReducers[Type]>\r\n    : ActionCreatorForCaseReducer<CaseReducers[Type]>\r\n}\r\n\r\n/**\r\n * Get a `PayloadActionCreator` type for a passed `CaseReducerWithPrepare`\r\n *\r\n * @internal\r\n */\r\ntype ActionCreatorForCaseReducerWithPrepare<\r\n  CR extends { prepare: any }\r\n> = _ActionCreatorWithPreparedPayload<CR['prepare'], string>\r\n\r\n/**\r\n * Get a `PayloadActionCreator` type for a passed `CaseReducer`\r\n *\r\n * @internal\r\n */\r\ntype ActionCreatorForCaseReducer<CR> = CR extends (\r\n  state: any,\r\n  action: infer Action\r\n) => any\r\n  ? Action extends { payload: infer P }\r\n    ? PayloadActionCreator<P>\r\n    : ActionCreatorWithoutPayload\r\n  : ActionCreatorWithoutPayload\r\n\r\n/**\r\n * Extracts the CaseReducers out of a `reducers` object, even if they are\r\n * tested into a `CaseReducerWithPrepare`.\r\n *\r\n * @internal\r\n */\r\ntype SliceDefinedCaseReducers<CaseReducers extends SliceCaseReducers<any>> = {\r\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends {\r\n    reducer: infer Reducer\r\n  }\r\n    ? Reducer\r\n    : CaseReducers[Type]\r\n}\r\n\r\n/**\r\n * Used on a SliceCaseReducers object.\r\n * Ensures that if a CaseReducer is a `CaseReducerWithPrepare`, that\r\n * the `reducer` and the `prepare` function use the same type of `payload`.\r\n *\r\n * Might do additional such checks in the future.\r\n *\r\n * This type is only ever useful if you want to write your own wrapper around\r\n * `createSlice`. Please don't use it otherwise!\r\n *\r\n * @public\r\n */\r\nexport type ValidateSliceCaseReducers<\r\n  S,\r\n  ACR extends SliceCaseReducers<S>\r\n> = ACR &\r\n  {\r\n    [T in keyof ACR]: ACR[T] extends {\r\n      reducer(s: S, action?: infer A): any\r\n    }\r\n      ? {\r\n          prepare(...a: never[]): Omit<A, 'type'>\r\n        }\r\n      : {}\r\n  }\r\n\r\nfunction getType(slice: string, actionKey: string): string {\r\n  return `${slice}/${actionKey}`\r\n}\r\n\r\n/**\r\n * A function that accepts an initial state, an object full of reducer\r\n * functions, and a \"slice name\", and automatically generates\r\n * action creators and action types that correspond to the\r\n * reducers and state.\r\n *\r\n * The `reducer` argument is passed to `createReducer()`.\r\n *\r\n * @public\r\n */\r\nexport function createSlice<\r\n  State,\r\n  CaseReducers extends SliceCaseReducers<State>,\r\n  Name extends string = string\r\n>(\r\n  options: CreateSliceOptions<State, CaseReducers, Name>\r\n): Slice<State, CaseReducers, Name> {\r\n  const { name, initialState } = options\r\n  if (!name) {\r\n    throw new Error('`name` is a required option for createSlice')\r\n  }\r\n  const reducers = options.reducers || {}\r\n  const [\r\n    extraReducers = {},\r\n    actionMatchers = [],\r\n    defaultCaseReducer = undefined\r\n  ] =\r\n    typeof options.extraReducers === 'undefined'\r\n      ? []\r\n      : typeof options.extraReducers === 'function'\r\n      ? executeReducerBuilderCallback(options.extraReducers)\r\n      : [options.extraReducers]\r\n\r\n  const reducerNames = Object.keys(reducers)\r\n\r\n  const sliceCaseReducersByName: Record<string, CaseReducer> = {}\r\n  const sliceCaseReducersByType: Record<string, CaseReducer> = {}\r\n  const actionCreators: Record<string, Function> = {}\r\n\r\n  reducerNames.forEach(reducerName => {\r\n    const maybeReducerWithPrepare = reducers[reducerName]\r\n    const type = getType(name, reducerName)\r\n\r\n    let caseReducer: CaseReducer<State, any>\r\n    let prepareCallback: PrepareAction<any> | undefined\r\n\r\n    if ('reducer' in maybeReducerWithPrepare) {\r\n      caseReducer = maybeReducerWithPrepare.reducer\r\n      prepareCallback = maybeReducerWithPrepare.prepare\r\n    } else {\r\n      caseReducer = maybeReducerWithPrepare\r\n    }\r\n\r\n    sliceCaseReducersByName[reducerName] = caseReducer\r\n    sliceCaseReducersByType[type] = caseReducer\r\n    actionCreators[reducerName] = prepareCallback\r\n      ? createAction(type, prepareCallback)\r\n      : createAction(type)\r\n  })\r\n\r\n  const finalCaseReducers = { ...extraReducers, ...sliceCaseReducersByType }\r\n  const reducer = createReducer(\r\n    initialState,\r\n    finalCaseReducers as any,\r\n    actionMatchers,\r\n    defaultCaseReducer\r\n  )\r\n\r\n  return {\r\n    name,\r\n    reducer,\r\n    actions: actionCreators as any,\r\n    caseReducers: sliceCaseReducersByName as any\r\n  }\r\n}\r\n","import createNextState, { Draft, isDraft, isDraftable } from 'immer'\r\nimport { AnyAction, Action, Reducer } from 'redux'\r\nimport {\r\n  executeReducerBuilderCallback,\r\n  ActionReducerMapBuilder\r\n} from './mapBuilders'\r\nimport { NoInfer } from './tsHelpers'\r\n\r\n/**\r\n * Defines a mapping from action types to corresponding action object shapes.\r\n *\r\n * @deprecated This should not be used manually - it is only used for internal\r\n *             inference purposes and should not have any further value.\r\n *             It might be removed in the future.\r\n * @public\r\n */\r\nexport type Actions<T extends keyof any = string> = Record<T, Action>\r\n\r\nexport interface ActionMatcher<A extends AnyAction> {\r\n  (action: AnyAction): action is A\r\n}\r\n\r\nexport type ActionMatcherDescription<S, A extends AnyAction> = {\r\n  matcher: ActionMatcher<A>\r\n  reducer: CaseReducer<S, NoInfer<A>>\r\n}\r\n\r\nexport type ActionMatcherDescriptionCollection<S> = Array<\r\n  ActionMatcherDescription<S, any>\r\n>\r\n\r\n/**\r\n * An *case reducer* is a reducer function for a specific action type. Case\r\n * reducers can be composed to full reducers using `createReducer()`.\r\n *\r\n * Unlike a normal Redux reducer, a case reducer is never called with an\r\n * `undefined` state to determine the initial state. Instead, the initial\r\n * state is explicitly specified as an argument to `createReducer()`.\r\n *\r\n * In addition, a case reducer can choose to mutate the passed-in `state`\r\n * value directly instead of returning a new state. This does not actually\r\n * cause the store state to be mutated directly; instead, thanks to\r\n * [immer](https://github.com/mweststrate/immer), the mutations are\r\n * translated to copy operations that result in a new state.\r\n *\r\n * @public\r\n */\r\nexport type CaseReducer<S = any, A extends Action = AnyAction> = (\r\n  state: Draft<S>,\r\n  action: A\r\n) => S | void\r\n\r\n/**\r\n * A mapping from action types to case reducers for `createReducer()`.\r\n *\r\n * @deprecated This should not be used manually - it is only used\r\n *             for internal inference purposes and using it manually\r\n *             would lead to type erasure.\r\n *             It might be removed in the future.\r\n * @public\r\n */\r\nexport type CaseReducers<S, AS extends Actions> = {\r\n  [T in keyof AS]: AS[T] extends Action ? CaseReducer<S, AS[T]> : void\r\n}\r\n\r\n/**\r\n * A utility function that allows defining a reducer as a mapping from action\r\n * type to *case reducer* functions that handle these action types. The\r\n * reducer's initial state is passed as the first argument.\r\n *\r\n * The body of every case reducer is implicitly wrapped with a call to\r\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\r\n * This means that rather than returning a new state object, you can also\r\n * mutate the passed-in state object directly; these mutations will then be\r\n * automatically and efficiently translated into copies, giving you both\r\n * convenience and immutability.\r\n *\r\n * @param initialState The initial state to be returned by the reducer.\r\n * @param actionsMap A mapping from action types to action-type-specific\r\n *   case reducers.\r\n * @param actionMatchers An array of matcher definitions in the form `{matcher, reducer}`.\r\n *   All matching reducers will be executed in order, independently if a case reducer matched or not.\r\n * @param defaultCaseReducer A \"default case\" reducer that is executed if no case reducer and no matcher\r\n *   reducer was executed for this action.\r\n *\r\n * @public\r\n */\r\nexport function createReducer<\r\n  S,\r\n  CR extends CaseReducers<S, any> = CaseReducers<S, any>\r\n>(\r\n  initialState: S,\r\n  actionsMap: CR,\r\n  actionMatchers?: ActionMatcherDescriptionCollection<S>,\r\n  defaultCaseReducer?: CaseReducer<S>\r\n): Reducer<S>\r\n/**\r\n * A utility function that allows defining a reducer as a mapping from action\r\n * type to *case reducer* functions that handle these action types. The\r\n * reducer's initial state is passed as the first argument.\r\n *\r\n * The body of every case reducer is implicitly wrapped with a call to\r\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\r\n * This means that rather than returning a new state object, you can also\r\n * mutate the passed-in state object directly; these mutations will then be\r\n * automatically and efficiently translated into copies, giving you both\r\n * convenience and immutability.\r\n * @param initialState The initial state to be returned by the reducer.\r\n * @param builderCallback A callback that receives a *builder* object to define\r\n *   case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\r\n *\r\n * @public\r\n */\r\nexport function createReducer<S>(\r\n  initialState: S,\r\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\r\n): Reducer<S>\r\n\r\nexport function createReducer<S>(\r\n  initialState: S,\r\n  mapOrBuilderCallback:\r\n    | CaseReducers<S, any>\r\n    | ((builder: ActionReducerMapBuilder<S>) => void),\r\n  actionMatchers: ActionMatcherDescriptionCollection<S> = [],\r\n  defaultCaseReducer?: CaseReducer<S>\r\n): Reducer<S> {\r\n  let [actionsMap, finalActionMatchers, finalDefaultCaseReducer] =\r\n    typeof mapOrBuilderCallback === 'function'\r\n      ? executeReducerBuilderCallback(mapOrBuilderCallback)\r\n      : [mapOrBuilderCallback, actionMatchers, defaultCaseReducer]\r\n\r\n  return function(state = initialState, action): S {\r\n    let caseReducers = [\r\n      actionsMap[action.type],\r\n      ...finalActionMatchers\r\n        .filter(({ matcher }) => matcher(action))\r\n        .map(({ reducer }) => reducer)\r\n    ]\r\n    if (caseReducers.filter(cr => !!cr).length === 0) {\r\n      caseReducers = [finalDefaultCaseReducer]\r\n    }\r\n\r\n    return caseReducers.reduce((previousState, caseReducer): S => {\r\n      if (caseReducer) {\r\n        if (isDraft(previousState)) {\r\n          // If it's already a draft, we must already be inside a `createNextState` call,\r\n          // likely because this is being wrapped in `createReducer`, `createSlice`, or nested\r\n          // inside an existing draft. It's safe to just pass the draft to the mutator.\r\n          const draft = previousState as Draft<S> // We can assume this is already a draft\r\n          const result = caseReducer(draft, action)\r\n\r\n          if (typeof result === 'undefined') {\r\n            return previousState\r\n          }\r\n\r\n          return result\r\n        } else if (!isDraftable(previousState)) {\r\n          // If state is not draftable (ex: a primitive, such as 0), we want to directly\r\n          // return the caseReducer func and not wrap it with produce.\r\n          const result = caseReducer(previousState as any, action)\r\n\r\n          if (typeof result === 'undefined') {\r\n            throw Error(\r\n              'A case reducer on a non-draftable value must not return undefined'\r\n            )\r\n          }\r\n\r\n          return result\r\n        } else {\r\n          // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\r\n          // than an Immutable<S>, and TypeScript cannot find out how to reconcile\r\n          // these two types.\r\n          return createNextState(previousState, (draft: Draft<S>) => {\r\n            return caseReducer(draft, action)\r\n          })\r\n        }\r\n      }\r\n\r\n      return previousState\r\n    }, state)\r\n  }\r\n}\r\n","import { Grid } from 'types';\n\nexport const checkSolution = (userGrid: Grid, solutionGrid: Grid) => {\n  const userList = userGrid.flat(1);\n  const solutionList = solutionGrid.flat(1);\n  return solutionList.every((value, index) => value === userList[index]);\n};\n","import { createWorker } from 'workerize-redux';\n\nimport { createNewGameFromWasm, createNewGame } from '../utils';\nimport { RootState } from '../app/rootReducer';\nimport { newGameFromWorker } from '../slices/gridSlice';\n\ncreateWorker<RootState>(async (state, action) => {\n  switch (action.type) {\n    case newGameFromWorker.toString():\n      return await createNewGameFromWasm(state?.gridReducer.difficulty);\n  }\n});\n\nexport default {};\n"],"sourceRoot":""}